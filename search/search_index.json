{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentation","text":""},{"location":"#welcome-to-sippy","title":"Welcome to SIPPY","text":""},{"location":"#systems-identification-package-for-python-sippy","title":"Systems Identification Package for PYthon (SIPPY)","text":"<p>SIPPY is a library for linear model identification of dynamic systems. It aims to be the most user-friendly and comprehensive library for system identification in Python.</p> <p>Originally developed by Giuseppe Armenise under supervision of Prof. Gabriele Pannocchia.</p>"},{"location":"#quickstart","title":"\u26a1\ufe0f Quickstart","text":"<p>To identify system as Auto-Regressive with eXogenous Inputs model (ARX) using Linear Least Squares  (LLS) on example data, simply run:</p> <pre><code>from sippy_unipi import system_identification\nfrom sippy_unipi.datasets import load_sample_siso\n\nY, U = load_sample_siso()\n\nId_ARX = system_identification(\n    Y,\n    U,\n    \"ARX\",\n    *([4], [[3]], [2], [[11]]),\n    id_mode=\"LLS\",\n)\n</code></pre> <p>Get your hand on the algorithms using following Jupyter notebooks and play around with open-spource example data:</p> <ul> <li>ARX systems (multi input-multi output case)</li> <li>ARMAX systems (single input-single output case)</li> <li>ARMAX systems (multi input-multi output case)</li> <li>Input-output structures (using optimization methods)</li> <li>Input-output structures (using recursive methods)</li> <li>State space system (multi input-multi output case)</li> <li>Continuous Stirred Tank Reactor</li> </ul>"},{"location":"#installation","title":"\ud83d\udee0 Installation","text":"<p>Intended to work with Python 3.10 and above.</p> <p>Simply run:</p> <pre><code>pip install sippy_unipi\n</code></pre> <p>To install from source, use poetry:</p> <pre><code>poetry install\n</code></pre> <p>Alternatively, you can use Docker to set up the environment. Follow these steps:</p> <ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/CPCLAB-UNIPI/SIPPY.git\ncd SIPPY\n</code></pre> </li> <li> <p>Build the Docker image:</p> <pre><code>docker build -t sippy .\n</code></pre> </li> <li> <p>Run the Docker container:</p> <pre><code>docker run -it --rm sippy\n</code></pre> </li> </ol>"},{"location":"#features","title":"\ud83d\udd2e Features","text":"<p>SIPPY provides implementations of the following:</p>"},{"location":"#input-output-models","title":"Input-Output Models","text":"<ul> <li>FIR</li> <li>ARX</li> <li>ARMAX</li> <li>ARMA</li> <li>ARARX</li> <li>ARARMAX</li> <li>OE</li> <li>BJ</li> <li>GEN</li> </ul>"},{"location":"#state-space-models","title":"State-Space Models","text":"<ul> <li>N4SID</li> <li>MOESP</li> <li>CVA</li> <li>PARSIM_P</li> <li>PARSIM_S</li> <li>PARSIM_K</li> </ul>"},{"location":"#contributing","title":"\ud83d\udc50 Contributing","text":"<p>Feel free to contribute in any way you like, we're always open to new ideas and approaches.</p> <ul> <li>Feel welcome to open an issue if you think you've spotted a bug or a performance issue.</li> </ul>"},{"location":"#affiliations","title":"\ud83e\udd1d Affiliations","text":"<ul> <li>University of Pisa, Department of Civil and Industrial Engineering (DICI), Chemical Process Control Laboratory (CPCLab)</li> <li>Slovak University of Technology in Bratislava, Department of Information Engineering and Process Control (DIEPC)</li> </ul>"},{"location":"#citation","title":"\ud83d\udcac Citation","text":"<p>If the service or the algorithm has been useful to you and you would like to cite it in an scientific publication, please refer to the paper:</p> <pre><code>@inproceedings{Armenise2018,\n  title         = {An Open-Source System Identification Package for Multivariable Processes},\n  author        = {Armenise, Giuseppe and Vaccari, Marco and {Bacci di Capaci}, Riccardo and Pannocchia, Gabriele},\n  booktitle     = {2018 UKACC 12th International Conference on Control (CONTROL)},\n  pages         = {152--157},\n  year          = {2018},\n  organization  = {IEEE}\n}\n</code></pre>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>This algorithm is free and open-source software licensed under the LGPL. license, meaning the code can be used royalty-free even in commercial applications.</p>"},{"location":"examples/armax-ic/","title":"ARMAX Example using Information Criterion","text":"<pre><code>import control.matlab as cnt\nimport numpy as np\nfrom utils import plot_bode, plot_response, plot_responses\n\nfrom sippy_unipi import system_identification\nfrom sippy_unipi.datasets import gen_gbn_seq, load_sample_siso, white_noise_var\n\nseed = 0\nnp.random.seed(seed)\n</code></pre> <pre><code>n_samples = 401\nts = 1.0\ntime, Ysim, Usim, g_sys, Yerr, Uerr, h_sys, Ytot, Utot = load_sample_siso(\n    n_samples, ts, seed=seed\n)\n</code></pre> <pre><code>fig = plot_responses(\n    time,\n    [Usim, Uerr, Utot],\n    [Ysim, Yerr, Ytot],\n    [\"u\", \"e\", [\"u\", \"e\"]],\n)\n</code></pre>"},{"location":"examples/armax-ic/#perform-system-identification-from-collected-data","title":"Perform system identification from collected data","text":"<pre><code>sys_id = system_identification(\n    Ytot,\n    Usim,\n    \"ARMAX\",\n    *((1, 5), (1, 5), (1, 5), (1, 13)),\n    IC=\"BIC\",\n    centering=\"MeanVal\",\n    max_iter=1000,\n)\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/sippy_unipi/io/opt.py:96: UserWarning: Reached maximum number of iterations\n  warn(\"Reached maximum number of iterations\")\n</code></pre>"},{"location":"examples/armax-ic/#check-that-output-of-the-identified-system-is-consistent","title":"Check that output of the identified system is consistent","text":"<pre><code>Y_id1, time, Xsim = cnt.lsim(sys_id.G, Usim, time)\nY_hid1, time, Xsim = cnt.lsim(sys_id.H, Uerr, time)\nY_idTot = Y_id1 + Y_hid1\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/timeresp.py:1083: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.\n  warnings.warn(\n</code></pre> <pre><code>fig = plot_response(\n    time,\n    [Ytot, Y_idTot],\n    Usim,\n    legends=[[\"system\", \"armax\"], [\"U\"]],\n    titles=[\n        \"Output (identification data)\",\n        \"Input, identification data (Switch probability=0.08)\",\n    ],\n)\n</code></pre>"},{"location":"examples/armax-ic/#validation-of-the-identified-system","title":"Validation of the identified system:","text":""},{"location":"examples/armax-ic/#generate-new-time-series-for-input-and-noise","title":"Generate new time series for input and noise","text":"<pre><code>switch_probability = 0.07  # [0..1]\ninput_range = [0.5, 1.5]\nU_valid, _, _ = gen_gbn_seq(n_samples, switch_probability, scale=input_range)\nwhite_noise_variance = [0.01]\ne_valid = white_noise_var(U_valid.size, white_noise_variance)[0]\n</code></pre>"},{"location":"examples/armax-ic/#compute-time-responses-for-true-system-with-new-inputs","title":"Compute time responses for true system with new inputs","text":"<pre><code>Yvalid1, time, Xsim = cnt.lsim(g_sys, U_valid, time)\nYvalid2, time, Xsim = cnt.lsim(h_sys, e_valid, time)\nYtotvalid = Yvalid1 + Yvalid2\n</code></pre>"},{"location":"examples/armax-ic/#compute-time-responses-for-identified-system-with-new-inputs","title":"Compute time responses for identified system with new inputs","text":"<pre><code>y_idvalid1, time, Xsim = cnt.lsim(sys_id.G, U_valid, time)\ny_idvalid2, time, Xsim = cnt.lsim(sys_id.H, e_valid, time)\ny_idtotvalid = y_idvalid1 + y_idvalid2\n</code></pre>"},{"location":"examples/armax-ic/#check-responses-are-almost-equal","title":"Check responses are almost equal","text":"<pre><code>fig = plot_response(\n    time,\n    [Ytotvalid, y_idtotvalid],\n    Usim,\n    legends=[[\"system\", \"armax\"], [\"U\"]],\n    titles=[\n        \"Output (identification data)\",\n        \"Input, identification data (Switch probability=0.07)\",\n    ],\n)\n</code></pre> <pre><code>W_V = np.logspace(-3, 4, num=701)\nfor tf in [\"G\", \"H\"]:\n    syss_tfs = [\n        locals()[f\"{tf.lower()}_sys\"],\n        getattr(sys_id, tf),\n    ]\n    mags, fis, oms = zip(*[cnt.bode(sys, W_V) for sys in syss_tfs])\n\n    fig = plot_bode(\n        oms[0],\n        mags,\n        fis,\n        [\"system\"],\n    )\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n</code></pre>"},{"location":"examples/armax-mimo/","title":"ARMAX MIMO Example","text":"<p>Example ARMAX MIMO case with 3 outputs and 4 inputs.</p> <pre><code># Checking path to access other files\nimport numpy as np\nfrom utils import plot_comparison\n\nfrom sippy_unipi import system_identification\nfrom sippy_unipi.datasets import load_sample_mimo\nfrom sippy_unipi.evaluate import validation\n\nseed = 0\nnp.random.seed(seed)\n</code></pre> <pre><code>n_samples = 401\nts = 1.0\ntime, Ysim, Usim, g_sys, Yerr, Uerr, h_sys, Ytot, Utot = load_sample_mimo(\n    n_samples, ts, seed=seed\n)\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/timeresp.py:1083: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.\n  warnings.warn(\n</code></pre>"},{"location":"examples/armax-mimo/#identification-parameters","title":"Identification Parameters","text":"<pre><code>na = [3, 1, 2]\nnb = [[2, 1, 3, 2], [3, 2, 1, 1], [1, 2, 1, 2]]\nth = [[1, 2, 2, 1], [1, 2, 0, 0], [0, 1, 0, 2]]\nnc = [2, 2, 3]\n\nordersna = na\nordersnb = nb\nordersnc = nc\ntheta_list = th\n\n# IDENTIFICATION STAGE\n# TESTING ARMAX models\norders = [ordersna, ordersnb, ordersnc, theta_list]\nidentification_params = {\n    \"ARMAX-I\": {\n        \"id_mode\": \"ILLS\",\n        \"max_iter\": 20,\n        \"centering\": \"MeanVal\",\n    },\n    \"ARMAX-O\": {\n        \"id_mode\": \"OPT\",\n        \"max_iter\": 20,\n        \"centering\": \"MeanVal\",\n    },\n    \"ARMAX-R\": {\n        \"id_mode\": \"RLLS\",\n        \"max_iter\": 20,\n        \"centering\": \"MeanVal\",\n    },\n}\n</code></pre> <pre><code>syss = []\nfor method, params in identification_params.items():\n    sys_id = system_identification(Ytot, Usim, \"ARMAX\", *orders, **params)\n    syss.append(sys_id)\n\nYouts = [getattr(sys, \"y_id\") for sys in syss]\n</code></pre>"},{"location":"examples/armax-mimo/#plot-identification-results","title":"Plot Identification Results","text":"<pre><code>fig = plot_comparison(\n    time,\n    [Ytot] + Youts,\n    ylabels=[f\"$y_{i}$\" for i in range(3)],\n    legend=[\"System\", \"ARMAX-I\", \"ARMAX-O\", \"ARMAX-R\"],\n    title=\"Output (identification data)\",\n)\n\nfig = plot_comparison(\n    time,\n    Usim,\n    [r\"$u_\\mathrm{GBN, \" + str(i) + \"}$\" for i in range(Usim.shape[1])],\n    title=\"Input (Switch probability=0.03) (identification data)\",\n)\n</code></pre>"},{"location":"examples/armax-mimo/#validation-stage","title":"Validation Stage","text":"<pre><code>time, Ysim, Usim_v, g_sys, Yerr, Uerr, h_sys, Ytot_v, Utot_v = (\n    load_sample_mimo(\n        n_samples,\n        ts,\n        input_ranges=[(0.33, 0.7), (-2.0, -1.0), (1.3, 2.7), (1.0, 5.2)],\n        seed=seed,\n    )\n)\n\n# ## Compute time responses for identified systems with new inputs\nYv_armaxi = validation(syss[0], Usim_v, Ytot_v, time, centering=\"MeanVal\")\nYv_armaxo = validation(syss[1], Usim_v, Ytot_v, time)\nYv_armaxr = validation(syss[2], Usim_v, Ytot_v, time, centering=\"InitVal\")\n</code></pre>"},{"location":"examples/armax-mimo/#plot-validation-results","title":"Plot Validation Results","text":"<pre><code>fig = plot_comparison(\n    time,\n    [Ytot_v, Yv_armaxi, Yv_armaxo, Yv_armaxr],\n    ylabels=[f\"$y_{i}$\" for i in range(Ytot_v.shape[1])],\n    legend=[\"System\", \"ARMAX-I\", \"ARMAX-O\", \"ARMAX-R\"],\n    title=\"Output (validation data)\",\n)\n\nfig = plot_comparison(\n    time,\n    Usim_v,\n    [r\"$u_\\mathrm{GBN, \" + str(i) + \"}$\" for i in range(Usim_v.shape[1])],\n    title=\"Input (Switch probability=0.03) (validation data)\",\n)\n</code></pre>"},{"location":"examples/armax-siso/","title":"ARMAX Example","text":"<p>This notebook demonstrates the ARMAX model identification and validation process.</p> <pre><code>import control.matlab as cnt\nimport numpy as np\nfrom utils import (\n    W_V,\n    plot_bode,\n    plot_response,\n    plot_responses,\n)\n\nfrom sippy_unipi import system_identification\nfrom sippy_unipi.datasets import gen_gbn_seq, load_sample_siso, white_noise_var\nfrom sippy_unipi.evaluate import validation\n\nnp.random.seed(0)\n</code></pre>"},{"location":"examples/armax-siso/#load-sample-data","title":"Load Sample Data","text":"<pre><code>ylegends = [\"System\", \"ARMAX-I\", \"ARMAX-0\", \"ARMAX-R\"]\nn_samples = 401\nts = 1.0\ntime, Ysim, Usim, g_sys, Yerr, Uerr, h_sys, Ytot, Utot = load_sample_siso(\n    n_samples, ts, seed=0\n)\n\nfig = plot_responses(\n    time,\n    [Usim, Uerr, Utot],\n    [Ysim, Yerr, Ytot],\n    [\"u\", \"e\", [\"u\", \"e\"]],\n)\n</code></pre>"},{"location":"examples/armax-siso/#system-identification","title":"System Identification","text":"<pre><code>mode = \"FIXED\"\n\nif mode == \"IC\":\n    na_ord = [4, 4]\n    nb_ord = [3, 3]\n    nc_ord = [2, 2]\n    theta = [11, 11]\nelse:\n    na_ord = [4]\n    nb_ord = [[3]]\n    nc_ord = [2]\n    theta = [[11]]\n\nidentification_params = [\n    ((na_ord, nb_ord, nc_ord, theta), {\"IC\": \"BIC\", \"id_mode\": \"ILLS\"}),\n    ((na_ord, nb_ord, nc_ord, theta), {\"IC\": \"BIC\", \"id_mode\": \"OPT\"}),\n    ((na_ord, nb_ord, nc_ord, theta), {\"IC\": \"BIC\", \"id_mode\": \"RLLS\"}),\n]\n\nsyss = []\nfor orders_params in identification_params:\n    orders, params = orders_params\n    sys_id = system_identification(\n        Ytot, Usim, \"ARMAX\", *orders, ts=ts, max_iter=300, **params\n    )\n    syss.append(sys_id)\n\nys = [Ytot] + [getattr(sys, \"y_id\").T for sys in syss]\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/sippy_unipi/identification.py:99: UserWarning: Ignoring argument 'IC' as fixed orders are provided.\n  warn(\"Ignoring argument 'IC' as fixed orders are provided.\")\n</code></pre>"},{"location":"examples/armax-siso/#check-consistency-of-the-identified-system","title":"Check Consistency of the Identified System","text":"<pre><code>fig = plot_response(\n    time,\n    ys,\n    Usim,\n    legends=[ylegends, [\"U\"]],\n    titles=[\n        \"Output (identification data)\",\n        \"Input, identification data (Switch probability=0.08)\",\n    ],\n)\n</code></pre>"},{"location":"examples/armax-siso/#validation-of-the-identified-system","title":"Validation of the Identified System","text":"<pre><code>switch_probability = 0.07\ninput_range = (0.5, 1.5)\n[U_valid, _, _] = gen_gbn_seq(n_samples, switch_probability, scale=input_range)\nwhite_noise_variance = [0.01]\ne_valid = white_noise_var(U_valid.size, white_noise_variance)[0]\n\nYvalid1, time, Xsim = cnt.lsim(g_sys, U_valid, time)\nYvalid2, time, Xsim = cnt.lsim(h_sys, e_valid, time)\nYtotvalid = Yvalid1 + Yvalid2\n\nys = [Ytotvalid] + [validation(sys, U_valid, Ytotvalid, time) for sys in syss]\n\nfig = plot_response(\n    time,\n    ys,\n    Usim,\n    legends=[ylegends, [\"U\"]],\n    titles=[\n        \"Output (identification data)\",\n        \"Input, identification data (Switch probability=0.07)\",\n    ],\n)\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/timeresp.py:1083: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.\n  warnings.warn(\n</code></pre>"},{"location":"examples/armax-siso/#compute-rmse-and-explained-variance","title":"Compute RMSE and Explained Variance","text":"<pre><code>for y, sys in zip(ys, syss):\n    yv = y.T\n    rmse = np.round(np.sqrt(np.mean((Ytotvalid - yv) ** 2)), 2)\n    EV = 100.0 * (\n        np.round((1.0 - np.mean((Ytotvalid - yv) ** 2) / np.std(Ytotvalid)), 2)\n    )\n    print(f\"RMSE = {rmse}\")\n    print(f\"Explained Variance = {EV}%\")\n</code></pre> <pre><code>RMSE = 0.0\nExplained Variance = 100.0%\nRMSE = 17.87\nExplained Variance = -2474.0%\nRMSE = 17.86\nExplained Variance = -2473.0%\n</code></pre>"},{"location":"examples/armax-siso/#step-tests","title":"Step Tests","text":"<pre><code>u = np.ones_like(time)\nu[0] = 0\n\nfor tf in [\"G\", \"H\"]:\n    syss_tfs = [\n        locals()[f\"{tf.lower()}_sys\"],\n        *[getattr(sys, tf) for sys in syss],\n    ]\n    mags, fis, oms = zip(*[cnt.bode(sys, W_V) for sys in syss_tfs])\n\n    fig = plot_bode(\n        oms[0],\n        mags,\n        fis,\n        ylegends,\n    )\n\n    ys, _ = zip(*[cnt.step(sys, time) for sys in syss_tfs])\n\n    fig = plot_response(\n        time,\n        ys,\n        u,\n        legends=[ylegends, [\"U\"]],\n        titles=[\"Step Response G(z)\", None],\n    )\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n</code></pre>"},{"location":"examples/arx-mimo/","title":"Arx mimo","text":""},{"location":"examples/arx-mimo/#arx-mimo-example","title":"ARX MIMO Example","text":"<p>Case: 3 outputs x 4 inputs</p> <p>Author: Giuseppe Armenise, revised by RBdC</p> <pre><code># Checking path to access other files\nimport numpy as np\nfrom utils import plot_comparison\n\nfrom sippy_unipi import system_identification\nfrom sippy_unipi.datasets import load_sample_mimo\nfrom sippy_unipi.model import IO_MIMO_Model, IO_SISO_Model\n</code></pre> <pre><code>seed = 0\nnp.random.seed(0)\n</code></pre> <pre><code>na = [3, 1, 2]\nnb = [[2, 1, 3, 2], [3, 2, 1, 1], [1, 2, 1, 2]]\nth = [[1, 2, 2, 1], [1, 2, 0, 0], [0, 1, 0, 2]]\n\nn_samples = 401\nts = 1.0\ntime, Ysim, Usim, g_sys, Yerr, Uerr, h_sys, Ytot, Utot = load_sample_mimo(\n    n_samples, ts, seed=seed\n)\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/timeresp.py:1083: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.\n  warnings.warn(\n</code></pre>"},{"location":"examples/arx-mimo/#identification-parameters","title":"Identification Parameters","text":"<pre><code>ordersna = na\nordersnb = nb\ntheta_list = th\n</code></pre>"},{"location":"examples/arx-mimo/#identification-stage","title":"Identification Stage","text":"<pre><code># ARX\nId_ARX = system_identification(\n    Ytot,\n    Usim,\n    \"ARX\",\n    *(ordersna, ordersnb, theta_list),\n    id_mode=\"LLS\",\n)\n\n# FIR\nId_FIR = system_identification(\n    Ytot, Usim, \"FIR\", *([0, 0, 0], ordersnb, theta_list), id_mode=\"LLS\"\n)\n</code></pre>"},{"location":"examples/arx-mimo/#output-of-the-identified-model","title":"Output of the Identified Model","text":"<pre><code>if not isinstance(Id_ARX, IO_SISO_Model | IO_MIMO_Model):\n    raise RuntimeError(\"Model not identified\")\nif not isinstance(Id_FIR, IO_SISO_Model | IO_MIMO_Model):\n    raise RuntimeError(\"Model not identified\")\n\nYout_ARX = Id_ARX.y_id\nYout_FIR = Id_FIR.y_id\n</code></pre>"},{"location":"examples/arx-mimo/#plot-results","title":"Plot Results","text":"<pre><code>fig = plot_comparison(\n    time,\n    Usim,\n    [r\"$u_\\mathrm{GBN, \" + str(i) + \"}$\" for i in range(Usim.shape[1])],\n    title=\"Input (Switch probability=0.03) (validation data)\",\n)\n\nfig = plot_comparison(\n    time,\n    [Ytot, Yout_ARX, Yout_FIR],\n    ylabels=[f\"$y_{i}$\" for i in range(3)],\n    legend=[\"System\", \"ARX\", \"FIR\"],\n    title=\"Output (validation data)\",\n)\n</code></pre>"},{"location":"examples/cst-mimo/","title":"CST example","text":"<p>A Continuous Stirred Tank to be identified from input-output data</p> <pre><code>import numpy as np\nfrom utils import plot_comparison\n\nfrom sippy_unipi import SS_Model, system_identification\nfrom sippy_unipi.datasets import gen_gbn_seq, gen_rw_seq, white_noise_var\nfrom sippy_unipi.evaluate import validation\nfrom sippy_unipi.ss import lsim_process_form\nfrom sippy_unipi.typing import IOMethods\n\nseed = 0\nnp.random.seed(seed)\n</code></pre> <pre><code>ts = 1.0  # [min]\ntfin = 1000\nnpts = int(tfin // ts) + 1\nTime = np.linspace(0, tfin, npts)\n</code></pre>"},{"location":"examples/cst-mimo/#data","title":"Data","text":"<pre><code>V = 10.0  # tank volume [m^3]         --&gt; assumed to be constant\nro = 1100.0  # solution density [kg/m^3] --&gt; assumed to be constant\ncp = 4.180  # specific heat [kJ/kg*K]    --&gt; assumed to be constant\n# latent heat   [kJ/kg]     --&gt; assumed to be constant (Tvap = 100\u00b0C, Pvap = 1atm)\nLam = 2272.0\n# initial conditions\n# Ca_0\n# Tin_0\n</code></pre>"},{"location":"examples/cst-mimo/#variables","title":"Variables","text":"<p>4 Inputs - as v. manipulated Input Flow rate Fin           [m^3/min] Steam Flow rate W             [kg/min] - as disturbances Input Concentration Ca_in     [kg salt/m^3 solution] Input Temperature T_in        [\u00b0C] U = [F, W, Ca_in, T_in]</p> <pre><code>m = 4\n</code></pre> <p>2 Outputs Output Concentration Ca       [kg salt/m^3 solution]  (Ca = Ca_out) Output Temperature T          [\u00b0C]                    (T = T_out) X = [Ca, T]</p> <pre><code>p = 2\n</code></pre>"},{"location":"examples/cst-mimo/#function-with-nonlinear-system-dynamics","title":"Function with Nonlinear System Dynamics","text":"<pre><code>def Fdyn(X, U):\n    # Balances\n\n    # V is constant ---&gt; perfect Level Control\n    # ro*F_in = ro*F_out = ro*F --&gt; F = F_in = F_out at each instant\n\n    # Mass Balance on A\n    # Ca_in*F - Ca*F = V*dCA/dt\n    #\n    dx_0 = (U[2] * U[0] - X[0] * U[0]) / V\n\n    # Energy Balance\n    # ro*cp*F*T_in - ro*cp*F*T + W*Lam = (V*ro*cp)*dT/dt\n    #\n    dx_1 = (ro * cp * U[0] * U[3] - ro * cp * U[0] * X[1] + U[1] * Lam) / (\n        V * ro * cp\n    )\n    fx = np.append(dx_0, dx_1)\n    return fx\n</code></pre> <p>Build input sequences</p> <pre><code>U = np.zeros((m, npts))\n</code></pre> <p>manipulated inputs as GBN Input Flow rate Fin = F = U[0]    [m^3/min]</p> <pre><code>prob_switch_1 = 0.05\nF_min = 0.4\nF_max = 0.6\nRange_GBN_1 = (F_min, F_max)\n[U[0, :], _, _] = gen_gbn_seq(\n    npts, prob_switch_1, scale=Range_GBN_1, seed=seed\n)\n# Steam Flow rate W = U[1]          [kg/min]\nprob_switch_2 = 0.05\nW_min = 20\nW_max = 40\nRange_GBN_2 = (W_min, W_max)\n[U[1, :], _, _] = gen_gbn_seq(\n    npts, prob_switch_2, scale=Range_GBN_2, seed=seed\n)\n</code></pre> <p>disturbance inputs as RW (random-walk)</p> <p>Input Concentration Ca_in = U[2]  [kg salt/m^3 solution]</p> <pre><code>Ca_0 = 10.0  # initial condition\nsigma_Ca = 0.01  # variation\nU[2, :] = gen_rw_seq(npts, Ca_0, sigma=sigma_Ca, seed=seed)\n# Input Temperature T_in            [\u00b0C]\nTin_0 = 25.0  # initial condition\nsigma_T = 0.01  # variation\nU[3, :] = gen_rw_seq(npts, Tin_0, sigma=sigma_T, seed=seed)\n</code></pre>"},{"location":"examples/cst-mimo/#collect-data","title":"Collect Data","text":"<p>Output Initial conditions</p> <pre><code>Caout_0 = Ca_0\nTout_0 = (ro * cp * U[0, 0] * Tin_0 + U[1, 0] * Lam) / (ro * cp * U[0, 0])\nXo1 = Caout_0 * np.ones((1, npts))\nXo2 = Tout_0 * np.ones((1, npts))\nX = np.vstack((Xo1, Xo2))\n</code></pre> <p>Run Simulation</p> <pre><code>for j in range(npts - 1):\n    # Explicit Runge-Kutta 4 (TC dynamics is integrateed by hand)\n    Mx = 5  # Number of elements in each time step\n    dt = ts / Mx  # integration step\n    # Output &amp; Input\n    X0k = X[:, j]\n    Uk = U[:, j]\n    # Integrate the model\n    for i in range(Mx):\n        k1 = Fdyn(X0k, Uk)\n        k2 = Fdyn(X0k + dt / 2.0 * k1, Uk)\n        k3 = Fdyn(X0k + dt / 2.0 * k2, Uk)\n        k4 = Fdyn(X0k + dt * k3, Uk)\n        Xk_1 = X0k + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n    X[:, j + 1] = Xk_1\n</code></pre> <p>Add noise (with assigned variances)</p> <pre><code>var = [0.001, 0.001]\nnoise = white_noise_var(npts, var, seed=seed)\n</code></pre> <p>Build Output</p> <pre><code>Y = X + noise\n</code></pre>"},{"location":"examples/cst-mimo/#identificatino-stage-linear-models","title":"Identificatino Stage (Linear Models)","text":"<p>Orders</p> <pre><code>na_ords = [2, 2]\nnb_ords = [[1, 1, 1, 1], [1, 1, 1, 1]]\nnc_ords = [1, 1]\nnd_ords = [1, 1]\nnf_ords = [2, 2]\ntheta = [[1, 1, 1, 1], [1, 1, 1, 1]]\n# Number of iterations\nn_iter = 300\n</code></pre> <p>IN-OUT Models: ARX - ARMAX - OE - BJ - GEN</p> <pre><code>identification_params: dict[\n    IOMethods, tuple[tuple[list[int] | list[list[int]], ...], dict]\n] = {\n    \"ARX\": (\n        (na_ords, nb_ords, theta),\n        {\n            \"id_mode\": \"RLLS\",\n            \"centering\": \"MeanVal\",\n        },\n    ),\n    \"ARMAX\": (\n        (na_ords, nb_ords, nc_ords, theta),\n        {\n            \"centering\": \"MeanVal\",\n            \"max_iter\": n_iter,\n            \"id_mode\": \"OPT\",\n        },\n    ),\n    \"OE\": (\n        (nb_ords, nf_ords, theta),\n        {\n            \"centering\": \"MeanVal\",\n            \"max_iter\": n_iter,\n        },\n    ),\n    \"BJ\": (\n        (nb_ords, nc_ords, nd_ords, nf_ords, theta),\n        {\n            \"centering\": \"MeanVal\",\n            \"max_iter\": n_iter,\n            \"stab_cons\": False,\n        },\n    ),\n    \"GEN\": (\n        (na_ords, nb_ords, nc_ords, nd_ords, nf_ords, theta),\n        {\n            \"centering\": \"MeanVal\",\n            \"max_iter\": n_iter,\n            \"stab_cons\": True,\n            \"stab_marg\": 0.98,\n        },\n    ),\n}\n</code></pre> <pre><code>syss = []\nfor method, orders_params in identification_params.items():\n    orders, params = orders_params\n    sys_id = system_identification(Y, U, method, *orders, **params)\n    syss.append(sys_id)\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/sippy_unipi/utils/validation.py:51: UserWarning: One of the identified system is not stable\n  warn(\"One of the identified system is not stable\")\n/home/runner/work/SIPPY/SIPPY/sippy_unipi/utils/validation.py:58: UserWarning: Consider activating the stability constraint. The maximum pole is 1.0011877396688156  \n  warn(\n\n\n/home/runner/work/SIPPY/SIPPY/sippy_unipi/utils/validation.py:58: UserWarning: Consider activating the stability constraint. The maximum pole is 1.0011877396681073  \n  warn(\n</code></pre> <p>SS - mimo choose method</p> <pre><code>method = \"PARSIM_K\"\norder = 2\nsys_id = system_identification(Y, U, method, order)\nif not isinstance(sys_id, SS_Model):\n    raise ValueError(\"SS model not returned\")\n# GETTING RESULTS (Y_id)\n# SS\nx_ss, Y_ss = lsim_process_form(\n    sys_id.A, sys_id.B, sys_id.C, sys_id.D, U, sys_id.x0\n)\n</code></pre> <pre><code>Ys = [Y] + [getattr(sys, \"y_id\") for sys in syss] + [Y_ss]\n</code></pre> <p>PLOTS</p> <p>Inputs</p> <pre><code>fig = plot_comparison(\n    Time,\n    U,\n    [\n        \"$F [m^3/min]$\",\n        \"$W [kg/min]$\",\n        \"$C_{a_{in}} [kg/m^3]$\",\n        r\"$T_{in} [^\\circ{}C]$\",\n    ],\n)\n</code></pre> <p></p> <p>Outputs</p> <pre><code>fig = plot_comparison(\n    Time,\n    Ys,\n    [\"$Ca [kg/m^3]$\", r\"$T [^\\circ{}C]$\"],\n    legend=[\"Data\", \"ARX\", \"ARMAX\", \"OE\", \"BJ\", \"GEN\", \"SS\"],\n)\n</code></pre> <p></p> <p>VALIDATION STAGE</p> <p>Build new input sequences</p> <pre><code>U_val = np.zeros((m, npts))\n</code></pre> <p>manipulated inputs as GBN Input Flow rate Fin = F = U[0]    [m^3/min]</p> <pre><code>prob_switch_1 = 0.05\nF_min = 0.4\nF_max = 0.6\nRange_GBN_1 = (F_min, F_max)\n[U_val[0, :], _, _] = gen_gbn_seq(\n    npts, prob_switch_1, scale=Range_GBN_1, seed=seed\n)\n# Steam Flow rate W = U[1]          [kg/min]\nprob_switch_2 = 0.05\nW_min = 20\nW_max = 40\nRange_GBN_2 = (W_min, W_max)\n[U_val[1, :], _, _] = gen_gbn_seq(\n    npts, prob_switch_2, scale=Range_GBN_2, seed=seed\n)\n</code></pre> <p>disturbance inputs as RW (random-walk) Input Concentration Ca_in = U[2]  [kg salt/m^3 solution]</p> <pre><code>Ca_0 = 10.0  # initial condition\nsigma_Ca = 0.02  # variation\nU_val[2, :] = gen_rw_seq(npts, Ca_0, sigma=sigma_Ca, seed=seed)\n# Input Temperature T_in            [\u00b0C]\nTin_0 = 25.0  # initial condition\nsigma_T = 0.1  # variation\nU_val[3, :] = gen_rw_seq(npts, Tin_0, sigma=sigma_T, seed=seed)\n</code></pre> <p>COLLECT DATA</p> <p>Output Initial conditions</p> <pre><code>Caout_0 = Ca_0\nTout_0 = (ro * cp * U[0, 0] * Tin_0 + U[1, 0] * Lam) / (ro * cp * U[0, 0])\nXo1 = Caout_0 * np.ones((1, npts))\nXo2 = Tout_0 * np.ones((1, npts))\nX_val = np.vstack((Xo1, Xo2))\n</code></pre> <p>Run Simulation</p> <pre><code>for j in range(npts - 1):\n    # Explicit Runge-Kutta 4 (TC dynamics is integrateed by hand)\n    Mx = 5  # Number of elements in each time step\n    dt = ts / Mx  # integration step\n    # Output &amp; Input\n    X0k = X_val[:, j]\n    Uk = U_val[:, j]\n    # Integrate the model\n    for i in range(Mx):\n        k1 = Fdyn(X0k, Uk)\n        k2 = Fdyn(X0k + dt / 2.0 * k1, Uk)\n        k3 = Fdyn(X0k + dt / 2.0 * k2, Uk)\n        k4 = Fdyn(X0k + dt * k3, Uk)\n        Xk_1 = X0k + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n    X_val[:, j + 1] = Xk_1\n</code></pre> <p>Add noise (with assigned variances)</p> <pre><code>var = [0.01, 0.05]\nnoise_val = white_noise_var(npts, var, seed=seed)\n</code></pre> <p>Build Output</p> <pre><code>Y_val = X_val + noise_val\n</code></pre> <p>MODEL VALIDATION</p> <p>IN-OUT Models: ARX - ARMAX - OE - BJ</p> <pre><code>YS = []\nfor i, sys in enumerate(syss):\n    try:\n        YS.append(validation(sys, U_val, Y_val, Time, centering=\"MeanVal\"))\n    except Exception as e:\n        raise ValueError(\n            f\"Error in validation of model {[*identification_params.keys()][i]}:\\n{e}\"\n        )\nYv_arx, Yv_armax, Yv_oe, Yv_bj, Yv_gen = (\n    validation(sys, U_val, Y_val, Time, centering=\"MeanVal\") for sys in syss\n)\n# SS\nx_ss, Yv_ss = lsim_process_form(\n    sys_id.A, sys_id.B, sys_id.C, sys_id.D, U_val, sys_id.x0\n)\nYs_val = [Y_val] + [Yv_arx, Yv_armax, Yv_oe, Yv_bj, Yv_gen, Yv_ss]\n</code></pre> <p>PLOTS</p> <pre><code>fig = plot_comparison(\n    Time,\n    U_val,\n    [\n        \"$F [m^3/min]$\",\n        \"$W [kg/min]$\",\n        \"$C_{a_{in}} [kg/m^3]$\",\n        r\"$T_{in} [^\\circ{}C]$\",\n    ],\n)\n</code></pre> <p></p> <pre><code>fig = plot_comparison(\n    Time,\n    Ys_val,\n    [\"$Ca [kg/m^3]$\", r\"$T [^\\circ{}C]$\"],\n    legend=[\"Data\", \"ARX\", \"ARMAX\", \"OE\", \"BJ\", \"GEN\", \"SS\"],\n)\n</code></pre> <p></p>"},{"location":"examples/opt/","title":"Opt","text":""},{"location":"examples/opt/#optimization-based-identification-methods-for-general-input-output-model","title":"Optimization-Based Identification Methods for General Input-Output Model","text":"<p>This notebook demonstrates the use of optimization-based identification methods for general input-output models.</p> <pre><code># Import required libraries\nimport control.matlab as cnt\nimport numpy as np\nfrom utils import (\n    W_V,\n    plot_bode,\n    plot_response,\n    plot_responses,\n)\n\nfrom sippy_unipi import system_identification\nfrom sippy_unipi.datasets import gen_gbn_seq, load_sample_siso, white_noise_var\nfrom sippy_unipi.evaluate import validation\n\nnp.random.seed(0)\nylegends = [\"System\", \"ARMA\", \"ARARX\", \"ARARMAX\", \"OE\", \"BJ\", \"GEN\"]\n</code></pre> <pre><code># Load sample data\nn_samples = 401\nts = 1.0\ntime, Ysim, Usim, g_sys, Yerr, Uerr, h_sys, Ytot, Utot = load_sample_siso(\n    n_samples, ts, seed=0\n)\n\n# Plot input and output responses\nfig = plot_responses(\n    time,\n    [Usim, Uerr, Utot],\n    [Ysim, Yerr, Ytot],\n    [\"u\", \"e\", [\"u\", \"e\"]],\n)\n</code></pre> <p></p> <pre><code># Define identification parameters\nmode = \"FIXED\"\n\nif mode == \"IC\":\n    na_ord = [2, 2]\n    nb_ord = [3, 3]\n    nc_ord = [2, 2]\n    nd_ord = [3, 3]\n    nf_ord = [4, 4]\n    theta = [11, 11]\nelse:\n    na_ord = [2]\n    nb_ord = [[3]]\n    nc_ord = [2]\n    nd_ord = [3]\n    nf_ord = [4]\n    theta = [[11]]\n\nidentification_params = {\n    \"ARMA\": ((na_ord, nc_ord, theta), {\"IC\": \"BIC\"}),\n    \"ARARX\": ((na_ord, nb_ord, nd_ord, theta), {\"IC\": \"BIC\"}),\n    \"ARARMAX\": ((na_ord, nb_ord, nc_ord, nd_ord, theta), {\"IC\": \"BIC\"}),\n    \"OE\": ((nb_ord, nf_ord, theta), {\"IC\": \"BIC\"}),\n    \"BJ\": ((nb_ord, nc_ord, nd_ord, nf_ord, theta), {\"IC\": \"BIC\"}),\n    \"GEN\": (\n        (na_ord, nb_ord, nc_ord, nd_ord, nf_ord, theta),\n        {\"IC\": \"BIC\"},\n    ),\n}\n</code></pre> <pre><code># Perform system identification\nsyss = []\nfor method, orders_params in identification_params.items():\n    orders, params = orders_params\n    sys_id = system_identification(\n        Ytot, Usim, method, *orders, max_iter=300, id_mode=\"OPT\"\n    )\n    syss.append(sys_id)\n\nys = [getattr(sys, \"y_id\").T for sys in syss]\n</code></pre> <pre><code># Plot consistency of identified systems\nfig = plot_response(\n    time,\n    ys,\n    Usim,\n    legends=[ylegends, [\"U\"]],\n    titles=[\n        \"Output (identification data)\",\n        \"Input, identification data (Switch probability=0.08)\",\n    ],\n)\n</code></pre> <p></p> <pre><code># Validation of identified systems\nswitch_probability = 0.07\ninput_range = (0.5, 1.5)\n[U_valid, _, _] = gen_gbn_seq(n_samples, switch_probability, scale=input_range)\nwhite_noise_variance = [0.01]\ne_valid = white_noise_var(U_valid.size, white_noise_variance)[0]\n\nYvalid1, time, Xsim = cnt.lsim(g_sys, U_valid, time)\nYvalid2, time, Xsim = cnt.lsim(h_sys, e_valid, time)\nYtotvalid = Yvalid1 + Yvalid2\n\nys = [validation(sys, U_valid, Ytotvalid, time) for sys in syss]\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/timeresp.py:1083: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.\n  warnings.warn(\n</code></pre> <pre><code># Plot validation results\nfig = plot_response(\n    time,\n    ys,\n    Usim,\n    legends=[ylegends, [\"U\"]],\n    titles=[\n        \"Output (identification data)\",\n        \"Input, identification data (Switch probability=0.07)\",\n    ],\n)\n</code></pre> <p></p> <pre><code># Compute RMSE and Explained Variance\nfor y, sys in zip(ys, syss):\n    yv = y.T\n    rmse = np.round(np.sqrt(np.mean((Ytotvalid - yv) ** 2)), 2)\n    EV = 100.0 * (\n        np.round((1.0 - np.mean((Ytotvalid - yv) ** 2) / np.std(Ytotvalid)), 2)\n    )\n    print(f\"RMSE = {rmse}\")\n    print(f\"Explained Variance = {EV}%\")\n</code></pre> <pre><code>RMSE = 18.38\nExplained Variance = -2533.0%\nRMSE = 18.55\nExplained Variance = -2582.0%\nRMSE = nan\nExplained Variance = nan%\nRMSE = 6.239365790193098e+36\nExplained Variance = -3.0334346177840173e+74%\nRMSE = 18.37\nExplained Variance = -2529.0%\nRMSE = 18.56\nExplained Variance = -2584.0%\n\n\n/tmp/ipykernel_2712/1075725442.py:4: RuntimeWarning: overflow encountered in square\n  rmse = np.round(np.sqrt(np.mean((Ytotvalid - yv) ** 2)), 2)\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/numpy/_core/_methods.py:135: RuntimeWarning: overflow encountered in reduce\n  ret = umr_sum(arr, axis, dtype, out, keepdims, where=where)\n/tmp/ipykernel_2712/1075725442.py:6: RuntimeWarning: overflow encountered in square\n  np.round((1.0 - np.mean((Ytotvalid - yv) ** 2) / np.std(Ytotvalid)), 2)\n</code></pre> <pre><code># Step tests\nu = np.ones_like(time)\nu[0] = 0\n\nfor tf in [\"G\", \"H\"]:\n    syss_tfs = [\n        locals()[f\"{tf.lower()}_sys\"],\n        *[getattr(sys, tf) for sys in syss],\n    ]\n    mags, fis, oms = zip(*[cnt.bode(sys, W_V) for sys in syss_tfs])\n\n    fig = plot_bode(\n        oms[0],\n        mags,\n        fis,\n        ylegends,\n    )\n\n    ys, _ = zip(*[cnt.step(sys, time) for sys in syss_tfs])\n\n    fig = plot_response(\n        time,\n        ys,\n        u,\n        legends=[ylegends, [\"U\"]],\n        titles=[\"Step Response G(z)\", None],\n    )\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n</code></pre> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"examples/rls/","title":"Rls","text":""},{"location":"examples/rls/#recursive-least-squares","title":"Recursive Least Squares","text":"<pre><code>import control.matlab as cnt\nimport numpy as np\nfrom utils import (\n    W_V,\n    plot_bode,\n    plot_response,\n    plot_responses,\n)\n\nfrom sippy_unipi import system_identification\nfrom sippy_unipi.datasets import gen_gbn_seq, load_sample_siso, white_noise_var\nfrom sippy_unipi.evaluate import validation\nfrom sippy_unipi.typing import IOMethods\n\nnp.random.seed(0)\n</code></pre> <pre><code>modes = [\"FIXED\", \"IC\"]\nylegends = [\"System\", \"ARMAX\", \"ARX\", \"OE\"]\n\nn_samples = 401\nts = 1.0\ntime, Ysim, Usim, g_sys, Yerr, Uerr, h_sys, Ytot, Utot = load_sample_siso(\n    n_samples, ts, seed=0\n)\n</code></pre> <pre><code>fig = plot_responses(\n    time,\n    [Usim, Uerr, Utot],\n    [Ysim, Yerr, Ytot],\n    [\"u\", \"e\", [\"u\", \"e\"]],\n)\n</code></pre> <pre><code>for mode in modes:\n    if mode == \"IC\":\n        na_ord = (4, 4)\n        nb_ord = (3, 3)\n        nc_ord = (2, 2)\n        nd_ord = (3, 3)\n        nf_ord = (4, 4)\n        theta = (11, 11)\n\n    elif mode == \"FIXED\":\n        na_ord = [4]\n        nb_ord = [[3]]\n        nc_ord = [2]\n        nf_ord = [4]\n        theta = [[11]]\n\n    identification_params: dict[\n        IOMethods,\n        tuple[tuple[list[int] | list[list[int]] | tuple[int, int], ...], dict],\n    ] = {\n        \"ARMAX\": (\n            (na_ord, nb_ord, nc_ord, theta),\n            {\"IC\": \"BIC\", \"id_mode\": \"RLLS\"},\n        ),\n        \"ARX\": ((na_ord, nb_ord, theta), {\"IC\": \"BIC\", \"id_mode\": \"RLLS\"}),\n        \"OE\": ((nb_ord, nf_ord, theta), {\"IC\": \"BIC\", \"id_mode\": \"RLLS\"}),\n    }\n\n    syss = []\n    for method, orders_params in identification_params.items():\n        orders, params = orders_params\n        sys_id = system_identification(\n            Ytot, Usim, method, *orders, max_iter=300, **params\n        )\n        syss.append(sys_id)\n\n    ys = [Ytot] + [getattr(sys, \"y_id\").T for sys in syss]\n\n    fig = plot_response(\n        time,\n        ys,\n        Usim,\n        legends=[ylegends, [\"U\"]],\n        titles=[\n            \"Output (identification data)\",\n            \"Input, identification data (Switch probability=0.08)\",\n        ],\n    )\n\n    switch_probability = 0.07\n    input_range = (0.5, 1.5)\n    [U_valid, _, _] = gen_gbn_seq(\n        n_samples, switch_probability, scale=input_range\n    )\n    white_noise_variance = [0.01]\n    e_valid = white_noise_var(U_valid.size, white_noise_variance)[0]\n\n    Yvalid1, time, Xsim = cnt.lsim(g_sys, U_valid, time)\n    Yvalid2, time, Xsim = cnt.lsim(h_sys, e_valid, time)\n    Ytotvalid = Yvalid1 + Yvalid2\n\n    ys = [Ytotvalid] + [\n        validation(sys, U_valid, Ytotvalid, time) for sys in syss\n    ]\n\n    fig = plot_response(\n        time,\n        ys,\n        Usim,\n        legends=[ylegends, [\"U\"]],\n        titles=[\n            \"Input, identification data (Switch probability=0.07)\",\n            \"Output (identification data)\",\n        ],\n    )\n\n    for y, sys in zip(ys[1:], syss):\n        yv = y.T\n        rmse = np.sqrt(np.mean((Ytotvalid - yv) ** 2))\n        R2 = 1 - np.sum((Ytotvalid - yv) ** 2) / np.sum(\n            (Ytotvalid - np.mean(Ytotvalid)) ** 2\n        )\n        print(f\"RMSE = {rmse:.2f}\")\n        print(f\"R2 = {R2:.02f}\")\n\n    u = np.ones_like(time)\n    u[0] = 0\n\n    for tf in [\"G\", \"H\"]:\n        syss_tfs = [\n            locals()[f\"{tf.lower()}_sys\"],\n            *[getattr(sys, tf) for sys in syss],\n        ]\n        mags, fis, oms = zip(*[cnt.bode(sys, W_V) for sys in syss_tfs])\n\n        fig = plot_bode(\n            oms[0],\n            mags,\n            fis,\n            ylegends,\n        )\n\n        ys, _ = zip(*[cnt.step(sys, time) for sys in syss_tfs])\n\n        fig = plot_response(\n            time,\n            ys,\n            u,\n            legends=[ylegends, [\"U\"]],\n            titles=[\"Step Response G(z)\", None],\n        )\n</code></pre> <pre><code>/home/runner/work/SIPPY/SIPPY/sippy_unipi/identification.py:99: UserWarning: Ignoring argument 'IC' as fixed orders are provided.\n  warn(\"Ignoring argument 'IC' as fixed orders are provided.\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/timeresp.py:1083: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.\n  warnings.warn(\n\n\nRMSE = 44.51\nR2 = -5180.52\nRMSE = 48.01\nR2 = -6028.03\nRMSE = 657.74\nR2 = -1131686.22\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/timeresp.py:1083: UserWarning: return_x specified for a transfer function system. Internal conversion to state space used; results may meaningless.\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\nRMSE = 18.34\nR2 = -825.05\nRMSE = 18.35\nR2 = -825.52\nRMSE = 17.91\nR2 = -786.18\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n\n\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/lti.py:114: UserWarning: __call__: evaluation above Nyquist frequency\n  warn(\"__call__: evaluation above Nyquist frequency\")\n/home/runner/work/SIPPY/SIPPY/.venv/lib/python3.12/site-packages/control/freqplot.py:435: FutureWarning: bode_plot() return value of mag, phase, omega is deprecated; use frequency_response()\n  warnings.warn(\n</code></pre>"},{"location":"examples/state-space/","title":"State space","text":""},{"location":"examples/state-space/#state-space-system-identification-example","title":"State-Space System Identification Example","text":"<p>This notebook demonstrates state-space system identification using various methods.</p> <pre><code># Importing required libraries\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom sippy_unipi import SS_Model, system_identification\nfrom sippy_unipi.datasets import gen_gbn_seq, white_noise_var\nfrom sippy_unipi.ss import lsim_process_form\nfrom sippy_unipi.typing import SSMethods\n\nseed = 0\nnp.random.seed(seed)\n\nMETHOD: list[SSMethods] = [\n    \"CVA\",\n    \"MOESP\",\n    \"N4SID\",\n    \"PARSIM_K\",\n    \"PARSIM_P\",\n    \"PARSIM_S\",\n]\n</code></pre>"},{"location":"examples/state-space/#define-system-parameters","title":"Define System Parameters","text":"<pre><code># Sample time\nts = 1.0\n\n# SISO SS system (n = 2)\nA = np.array([[0.89, 0.0], [0.0, 0.45]])\nB = np.array([[0.3], [2.5]])\nC = np.array([[0.7, 1.0]])\nD = np.array([[0.0]])\n\ntfin = 500\nnpts = int(tfin // ts) + 1\nTime = np.linspace(0, tfin, npts)\n</code></pre>"},{"location":"examples/state-space/#generate-input-sequence-and-system-output","title":"Generate Input Sequence and System Output","text":"<pre><code># Input sequence\nU = np.zeros((1, npts))\n[U[0], _, _] = gen_gbn_seq(npts, 0.05)\n\n# Output\nx, yout = lsim_process_form(A, B, C, D, U)\n\n# Measurement noise\nnoise = white_noise_var(npts, [0.15])\n\n# Output with noise\ny_tot = yout + noise\n</code></pre>"},{"location":"examples/state-space/#plot-input-and-output","title":"Plot Input and Output","text":"<pre><code>fig, axs = plt.subplots(2, 1, sharex=True)\naxs[0].plot(Time, y_tot[0])\naxs[0].set_ylabel(\"y_tot\")\naxs[0].grid()\naxs[0].set_xlabel(\"Time\")\naxs[0].set_title(\"Ytot\")\n\nlegend = [\"System\"]\n\naxs[0].plot(Time, y_tot[0], label=\"System\")\nfor method in METHOD:\n    sys_id = system_identification(y_tot, U, method, 2, SS_threshold=0.1)\n    if not isinstance(sys_id, SS_Model):\n        raise ValueError(\"SS model not returned\")\n    xid, yid = lsim_process_form(\n        sys_id.A, sys_id.B, sys_id.C, sys_id.D, U, sys_id.x0\n    )\n    axs[0].plot(Time, yid[0], label=method)\naxs[0].legend()\n\naxs[1].plot(Time, U[0])\naxs[1].set_ylabel(\"input\")\naxs[1].grid()\naxs[1].set_xlabel(\"Time\")\n</code></pre> <pre><code>Text(0.5, 0, 'Time')\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>sippy_unipi<ul> <li>datasets<ul> <li>_base</li> <li>_input_generator</li> <li>_systems_generator</li> </ul> </li> <li>evaluate</li> <li>identification</li> <li>io<ul> <li>armax</li> <li>arx</li> <li>base</li> <li>opt</li> <li>rls</li> </ul> </li> <li>model</li> <li>ss<ul> <li>base</li> <li>olsim</li> <li>parsim</li> </ul> </li> <li>tf2ss<ul> <li>test_tf2ss</li> <li>tf2ss</li> <li>timeresp</li> </ul> </li> <li>typing</li> <li>utils<ul> <li>base</li> <li>validation</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/sippy_unipi/","title":"Index","text":""},{"location":"reference/sippy_unipi/#sippy_unipi","title":"sippy_unipi","text":"<p>Systems Identification Package for PYthon (SIPPY).</p> <p>Modules:</p> Name Description <code>datasets</code> <p>Load and fetch sample data for benchmarking and testing purposes.</p> <code>evaluate</code> <p>Evaluate performance of models</p> <code>io</code> <p>Input-Output Models</p> <code>model</code> <p>Classes for input-output and state-space models</p> <code>ss</code> <p>State-Space Models</p> <code>tf2ss</code> <p>Convert your MISO/SIMO/MIMO systems from transfer function to state-space.</p> <code>utils</code> <p>Helper functions and tools.</p>"},{"location":"reference/sippy_unipi/evaluate/","title":"evaluate","text":""},{"location":"reference/sippy_unipi/evaluate/#sippy_unipi.evaluate","title":"evaluate","text":"<p>Evaluate performance of models</p> <p>Functions:</p> Name Description <code>validation</code> <p>Model validation (one-step and k-step ahead predictor).</p>"},{"location":"reference/sippy_unipi/evaluate/#sippy_unipi.evaluate.validation","title":"validation","text":"<pre><code>validation(\n    sys: IO_SISO_Model | IO_MIMO_Model,\n    u: ndarray,\n    y: ndarray,\n    time: ndarray,\n    k: int = 1,\n    centering: CenteringMethods = None,\n) -&gt; ndarray\n</code></pre> <p>Model validation (one-step and k-step ahead predictor).</p> <p>This function is very useful when the user wants to cross-validate the identified input/output model, that is, test the previously identified model on new data not used in the identification stage.</p> <p>Parameters:</p> Name Type Description Default <code>IO_SISO_Model | IO_MIMO_Model</code> <p>system to validate (identified ARX or ARMAX model)</p> required <code>ndarray</code> <p>input data</p> required <code>ndarray</code> <p>output data</p> required <code>ndarray</code> <p>time sequence</p> required <code>int</code> <p>k-step ahead</p> <code>1</code>"},{"location":"reference/sippy_unipi/evaluate/#sippy_unipi.evaluate.validation(sys)","title":"<code>sys</code>","text":""},{"location":"reference/sippy_unipi/evaluate/#sippy_unipi.evaluate.validation(u)","title":"<code>u</code>","text":""},{"location":"reference/sippy_unipi/evaluate/#sippy_unipi.evaluate.validation(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/evaluate/#sippy_unipi.evaluate.validation(time)","title":"<code>time</code>","text":""},{"location":"reference/sippy_unipi/evaluate/#sippy_unipi.evaluate.validation(k)","title":"<code>k</code>","text":""},{"location":"reference/sippy_unipi/identification/","title":"identification","text":""},{"location":"reference/sippy_unipi/identification/#sippy_unipi.identification","title":"identification","text":""},{"location":"reference/sippy_unipi/model/","title":"model","text":""},{"location":"reference/sippy_unipi/model/#sippy_unipi.model","title":"model","text":"<p>Classes for input-output and state-space models</p>"},{"location":"reference/sippy_unipi/typing/","title":"typing","text":""},{"location":"reference/sippy_unipi/typing/#sippy_unipi.typing","title":"typing","text":""},{"location":"reference/sippy_unipi/datasets/","title":"Index","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets","title":"datasets","text":"<p>Load and fetch sample data for benchmarking and testing purposes.</p> <p>Functions:</p> Name Description <code>gen_gbn_seq</code> <p>Generate sequence of inputs GBN.</p> <code>gen_rw_seq</code> <p>Generate a sequence of inputs as Random walk.</p> <code>make_tf</code> <p>Generate a Transfer Function object of a system.</p> <code>white_noise</code> <p>Add a white noise to a signal y.</p> <code>white_noise_var</code> <p>Generate a white noise matrix (rows with zero mean).</p>"},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_gbn_seq","title":"gen_gbn_seq","text":"<pre><code>gen_gbn_seq(\n    n_samples: int,\n    p_swd: float,\n    n_min: int = 1,\n    scale: tuple[float, float] = (-1.0, 1.0),\n    tol: float = 0.01,\n    nit_max: int = 30,\n    seed: int | None = None,\n) -&gt; tuple[ndarray, float, int]\n</code></pre> <p>Generate sequence of inputs GBN.</p> <p>Generate Generalized Binary Noise (GBN), apseudo-random binary  sequence.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>sequence length (total number of samples)</p> required <code>float</code> <p>desired probability of switching (no switch: 0&lt;x&lt;1 :always switch)</p> required <code>int</code> <p>minimum number of samples between two switches</p> <code>1</code> <code>tuple[float, float]</code> <p>upper and lower values of the sequence</p> <code>(-1.0, 1.0)</code> <code>float</code> <p>tolerance on switching probability relative error</p> <code>0.01</code> <code>int</code> <p>maximum number of iterations to get the desired switching probability</p> <code>30</code> Return <p>array of given length and switching probability. actual probability of switching (which may differ a little from <code>p_swd</code> according to <code>tol</code>. number of switches in the sequence.</p> <p>Examples:</p> <p>Generating an array of length equal to 1000, 10% of switch probability, switching at least every 20 samples, between -10 or 5;</p> <pre><code>&gt;&gt;&gt; bn_b, p_sw_b, Nswb = gen_gbn_seq(1000, 0.1, 20, (-10, 5))\n</code></pre> References <p>Y. Zhu. Multivariable System Identification For Process Control. 2001.</p>"},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_gbn_seq(n_samples)","title":"<code>n_samples</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_gbn_seq(p_swd)","title":"<code>p_swd</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_gbn_seq(n_min)","title":"<code>n_min</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_gbn_seq(scale)","title":"<code>scale</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_gbn_seq(tol)","title":"<code>tol</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_gbn_seq(nit_max)","title":"<code>nit_max</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq","title":"gen_rw_seq","text":"<pre><code>gen_rw_seq(\n    n_samples: int,\n    rw0: float,\n    sigma: float = 1.0,\n    seed: int | None = None,\n) -&gt; ndarray\n</code></pre> <p>Generate a sequence of inputs as Random walk.</p> <p>Generate a random signal sequence (a random walk from a normal distribution).</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>sequence length (total number of samples);</p> required <code>float</code> <p>standard deviation (mobility) of randow walk</p> <code>1.0</code> <code>float</code> <p>initial value</p> required <p>Parameters:</p> Name Type Description Default <code>int</code> <p>sequence length (total number of samples)</p> required <code>float</code> <p>initial value</p> required <code>float</code> <p>standard deviation (mobility) of random walk</p> <code>1.0</code> <code>int | None</code> <p>seed for random number generator</p> <code>None</code> Return <p>array of given length and switching probability. actual probability of switching (which may differ a little from <code>p_swd</code> according to <code>tol</code>. number of switches in the sequence.</p> <p>Examples:</p> <p>Generating an array of length equal to 1000, 10% of switch probability, switching at least every 20 samples, between -10 or 5;</p> <pre><code>&gt;&gt;&gt; bn_b, p_sw_b, Nswb = gen_gbn_seq(1000, 0.1, 20, (-10, 5))\n</code></pre> References <p>Y. Zhu. Multivariable System Identification For Process Control. 2001.</p>"},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq(n_samples)","title":"<code>n_samples</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq(sigma)","title":"<code>sigma</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq(rw0)","title":"<code>rw0</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq(n_samples)","title":"<code>n_samples</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq(rw0)","title":"<code>rw0</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq(sigma)","title":"<code>sigma</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.gen_rw_seq(seed)","title":"<code>seed</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.make_tf","title":"make_tf","text":"<pre><code>make_tf(\n    numerator: list[float],\n    denominator: list[float],\n    ts: float = 1.0,\n    noise: float = 0.0,\n    random_state: int | None = None,\n) -&gt; TransferFunction\n</code></pre><pre><code>make_tf(\n    numerator: list[list[float]],\n    denominator: list[list[float]],\n    ts: float = 1.0,\n    noise: float = 0.0,\n    random_state: int | None = None,\n) -&gt; NestedTransferFunction\n</code></pre> <pre><code>make_tf(\n    numerator: list[float] | list[list[float]],\n    denominator: list[float] | list[list[float]],\n    ts: float = 1.0,\n    noise: float = 0.0,\n    random_state: int | None = None,\n) -&gt; TransferFunction | NestedTransferFunction\n</code></pre> <p>Generate a Transfer Function object of a system.</p> <p>Parameters:</p> Name Type Description Default <code>list[float] | list[list[float]]</code> <p>Numerator coefficients of the transfer function.</p> required <code>list[float] | list[list[float]]</code> <p>Denominator coefficients of the transfer function.</p> required <code>float</code> <p>Sampling time, by default 1.0.</p> <code>1.0</code> <code>float</code> <p>Standard deviation of Gaussian noise, by default 0.0.</p> <code>0.0</code> <code>int | None</code> <p>Random seed, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TransferFunction | NestedTransferFunction</code> <p>TransferFunction or nested structure of TransferFunctions.</p>"},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.make_tf(numerator)","title":"<code>numerator</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.make_tf(denominator)","title":"<code>denominator</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.make_tf(ts)","title":"<code>ts</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.make_tf(noise)","title":"<code>noise</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.make_tf(random_state)","title":"<code>random_state</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.white_noise","title":"white_noise","text":"<pre><code>white_noise(\n    y: ndarray, A_rel: float, seed: int | None = None\n)\n</code></pre> <p>Add a white noise to a signal y.</p> <p>noise amplitude=  A_rel*(standard deviation of y)</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>original signal</p> required <code>float</code> <p>relative amplitude (0&lt;x&lt;1) to the standard deviation of y</p> required <code>int | None</code> <p>random seed</p> <code>None</code>"},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.white_noise(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.white_noise(A_rel)","title":"<code>A_rel</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.white_noise(seed)","title":"<code>seed</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.white_noise_var","title":"white_noise_var","text":"<pre><code>white_noise_var(\n    L: int, Var: ndarray, seed: int | None = None\n) -&gt; ndarray\n</code></pre> <p>Generate a white noise matrix (rows with zero mean).</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>size (columns)</p> required <code>ndarray</code> <p>variance vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>white_noise_var(100,[1,1]) , noise matrix has two row vectors with variance=1</p>"},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.white_noise_var(L)","title":"<code>L</code>","text":""},{"location":"reference/sippy_unipi/datasets/#sippy_unipi.datasets.white_noise_var(Var)","title":"<code>Var</code>","text":""},{"location":"reference/sippy_unipi/datasets/_base/","title":"_base","text":""},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base","title":"_base","text":"<p>Functions:</p> Name Description <code>white_noise</code> <p>Add a white noise to a signal y.</p> <code>white_noise_var</code> <p>Generate a white noise matrix (rows with zero mean).</p>"},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base.white_noise","title":"white_noise","text":"<pre><code>white_noise(\n    y: ndarray, A_rel: float, seed: int | None = None\n)\n</code></pre> <p>Add a white noise to a signal y.</p> <p>noise amplitude=  A_rel*(standard deviation of y)</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>original signal</p> required <code>float</code> <p>relative amplitude (0&lt;x&lt;1) to the standard deviation of y</p> required <code>int | None</code> <p>random seed</p> <code>None</code>"},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base.white_noise(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base.white_noise(A_rel)","title":"<code>A_rel</code>","text":""},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base.white_noise(seed)","title":"<code>seed</code>","text":""},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base.white_noise_var","title":"white_noise_var","text":"<pre><code>white_noise_var(\n    L: int, Var: ndarray, seed: int | None = None\n) -&gt; ndarray\n</code></pre> <p>Generate a white noise matrix (rows with zero mean).</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>size (columns)</p> required <code>ndarray</code> <p>variance vector</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>white_noise_var(100,[1,1]) , noise matrix has two row vectors with variance=1</p>"},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base.white_noise_var(L)","title":"<code>L</code>","text":""},{"location":"reference/sippy_unipi/datasets/_base/#sippy_unipi.datasets._base.white_noise_var(Var)","title":"<code>Var</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/","title":"_input_generator","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator","title":"_input_generator","text":"<p>Functions:</p> Name Description <code>gen_gbn_seq</code> <p>Generate sequence of inputs GBN.</p> <code>gen_rw_seq</code> <p>Generate a sequence of inputs as Random walk.</p>"},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_gbn_seq","title":"gen_gbn_seq","text":"<pre><code>gen_gbn_seq(\n    n_samples: int,\n    p_swd: float,\n    n_min: int = 1,\n    scale: tuple[float, float] = (-1.0, 1.0),\n    tol: float = 0.01,\n    nit_max: int = 30,\n    seed: int | None = None,\n) -&gt; tuple[ndarray, float, int]\n</code></pre> <p>Generate sequence of inputs GBN.</p> <p>Generate Generalized Binary Noise (GBN), apseudo-random binary  sequence.</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>sequence length (total number of samples)</p> required <code>float</code> <p>desired probability of switching (no switch: 0&lt;x&lt;1 :always switch)</p> required <code>int</code> <p>minimum number of samples between two switches</p> <code>1</code> <code>tuple[float, float]</code> <p>upper and lower values of the sequence</p> <code>(-1.0, 1.0)</code> <code>float</code> <p>tolerance on switching probability relative error</p> <code>0.01</code> <code>int</code> <p>maximum number of iterations to get the desired switching probability</p> <code>30</code> Return <p>array of given length and switching probability. actual probability of switching (which may differ a little from <code>p_swd</code> according to <code>tol</code>. number of switches in the sequence.</p> <p>Examples:</p> <p>Generating an array of length equal to 1000, 10% of switch probability, switching at least every 20 samples, between -10 or 5;</p> <pre><code>&gt;&gt;&gt; bn_b, p_sw_b, Nswb = gen_gbn_seq(1000, 0.1, 20, (-10, 5))\n</code></pre> References <p>Y. Zhu. Multivariable System Identification For Process Control. 2001.</p>"},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_gbn_seq(n_samples)","title":"<code>n_samples</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_gbn_seq(p_swd)","title":"<code>p_swd</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_gbn_seq(n_min)","title":"<code>n_min</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_gbn_seq(scale)","title":"<code>scale</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_gbn_seq(tol)","title":"<code>tol</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_gbn_seq(nit_max)","title":"<code>nit_max</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq","title":"gen_rw_seq","text":"<pre><code>gen_rw_seq(\n    n_samples: int,\n    rw0: float,\n    sigma: float = 1.0,\n    seed: int | None = None,\n) -&gt; ndarray\n</code></pre> <p>Generate a sequence of inputs as Random walk.</p> <p>Generate a random signal sequence (a random walk from a normal distribution).</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>sequence length (total number of samples);</p> required <code>float</code> <p>standard deviation (mobility) of randow walk</p> <code>1.0</code> <code>float</code> <p>initial value</p> required <p>Parameters:</p> Name Type Description Default <code>int</code> <p>sequence length (total number of samples)</p> required <code>float</code> <p>initial value</p> required <code>float</code> <p>standard deviation (mobility) of random walk</p> <code>1.0</code> <code>int | None</code> <p>seed for random number generator</p> <code>None</code> Return <p>array of given length and switching probability. actual probability of switching (which may differ a little from <code>p_swd</code> according to <code>tol</code>. number of switches in the sequence.</p> <p>Examples:</p> <p>Generating an array of length equal to 1000, 10% of switch probability, switching at least every 20 samples, between -10 or 5;</p> <pre><code>&gt;&gt;&gt; bn_b, p_sw_b, Nswb = gen_gbn_seq(1000, 0.1, 20, (-10, 5))\n</code></pre> References <p>Y. Zhu. Multivariable System Identification For Process Control. 2001.</p>"},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq(n_samples)","title":"<code>n_samples</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq(sigma)","title":"<code>sigma</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq(rw0)","title":"<code>rw0</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq(n_samples)","title":"<code>n_samples</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq(rw0)","title":"<code>rw0</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq(sigma)","title":"<code>sigma</code>","text":""},{"location":"reference/sippy_unipi/datasets/_input_generator/#sippy_unipi.datasets._input_generator.gen_rw_seq(seed)","title":"<code>seed</code>","text":""},{"location":"reference/sippy_unipi/datasets/_systems_generator/","title":"_systems_generator","text":""},{"location":"reference/sippy_unipi/datasets/_systems_generator/#sippy_unipi.datasets._systems_generator","title":"_systems_generator","text":"<p>Functions:</p> Name Description <code>make_tf</code> <p>Generate a Transfer Function object of a system.</p>"},{"location":"reference/sippy_unipi/datasets/_systems_generator/#sippy_unipi.datasets._systems_generator.make_tf","title":"make_tf","text":"<pre><code>make_tf(\n    numerator: list[float],\n    denominator: list[float],\n    ts: float = 1.0,\n    noise: float = 0.0,\n    random_state: int | None = None,\n) -&gt; TransferFunction\n</code></pre><pre><code>make_tf(\n    numerator: list[list[float]],\n    denominator: list[list[float]],\n    ts: float = 1.0,\n    noise: float = 0.0,\n    random_state: int | None = None,\n) -&gt; NestedTransferFunction\n</code></pre> <pre><code>make_tf(\n    numerator: list[float] | list[list[float]],\n    denominator: list[float] | list[list[float]],\n    ts: float = 1.0,\n    noise: float = 0.0,\n    random_state: int | None = None,\n) -&gt; TransferFunction | NestedTransferFunction\n</code></pre> <p>Generate a Transfer Function object of a system.</p> <p>Parameters:</p> Name Type Description Default <code>list[float] | list[list[float]]</code> <p>Numerator coefficients of the transfer function.</p> required <code>list[float] | list[list[float]]</code> <p>Denominator coefficients of the transfer function.</p> required <code>float</code> <p>Sampling time, by default 1.0.</p> <code>1.0</code> <code>float</code> <p>Standard deviation of Gaussian noise, by default 0.0.</p> <code>0.0</code> <code>int | None</code> <p>Random seed, by default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>TransferFunction | NestedTransferFunction</code> <p>TransferFunction or nested structure of TransferFunctions.</p>"},{"location":"reference/sippy_unipi/datasets/_systems_generator/#sippy_unipi.datasets._systems_generator.make_tf(numerator)","title":"<code>numerator</code>","text":""},{"location":"reference/sippy_unipi/datasets/_systems_generator/#sippy_unipi.datasets._systems_generator.make_tf(denominator)","title":"<code>denominator</code>","text":""},{"location":"reference/sippy_unipi/datasets/_systems_generator/#sippy_unipi.datasets._systems_generator.make_tf(ts)","title":"<code>ts</code>","text":""},{"location":"reference/sippy_unipi/datasets/_systems_generator/#sippy_unipi.datasets._systems_generator.make_tf(noise)","title":"<code>noise</code>","text":""},{"location":"reference/sippy_unipi/datasets/_systems_generator/#sippy_unipi.datasets._systems_generator.make_tf(random_state)","title":"<code>random_state</code>","text":""},{"location":"reference/sippy_unipi/io/","title":"Index","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io","title":"io","text":"<p>Input-Output Models</p> <p>Every identified linear input-output model is returned according to the following structure:</p> \\[   y_k = G(z)u_k + H(z)e_k \\] <p>where \\( G(z) \\) and \\( H(z) \\) are transfer function matrices of polynomials in \\( z \\), which is the forward shift operator (see Figure~ ef{fig:gen_model}).</p> <p>Modules:</p> Name Description <code>armax</code> <p>Created on Fri Jul 28 2017</p> <code>arx</code> <p>Created on Wed Jul 26 2017</p> <code>base</code> <p>Helper functions for nonlinear optimization problem used by some of the identification functions.</p> <code>opt</code> <p>Created on 2021</p> <code>rls</code> <p>Created on 2021</p> <p>Classes:</p> Name Description <code>Armax</code> <p>Functions:</p> Name Description <code>ARX_MISO_id</code> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p> <code>ARX_id</code> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p>"},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.Armax","title":"Armax","text":"<pre><code>Armax(\n    G: TransferFunction,\n    H: TransferFunction,\n    *order_bounds: tuple[int, int],\n    Vn: float | floating,\n    y_id: ndarray,\n    method: ICMethods = \"AIC\"\n)\n</code></pre> <p>The AutoRegressive-Moving-Average with eXogenous inputs model is computed based on a recursive lest-square regression between the input data (U) and the measured output data (Y). As Y is noisy in practice, a white noise (E) is identified within the model. This model is designed to deal with potential time-delays between U and Y.</p> <p>SIPPY implements an iterative procedure, with   extit{iterative least-square regression} = <code>ILLS</code>.</p> <p>The following equations summarize the equations involved in the model:</p> <p>$$ Y = G.U + H.E</p> <p>G = B / A H = C / A</p> <p>A = 1 + a_1z^(-1) + ... + a_naz^(-na) B = b_1z^(-1-theta) + ... + b_nbz^(-nb-theta) C = c_1z^(-1) + ... + c_ncz^(-nc) $$</p> <p>Parameters:</p> Name Type Description Default <code>TransferFunction</code> <p>output response</p> required <code>TransferFunction</code> <p>noise response</p> required <code>tuple[int, int]</code> <p>extended range of the order of: - na_bounds: the common denominator - nb_bounds: the G numerator - nc_bounds: the H numerator - theta_bounds: the discrete theta in B</p> <code>()</code> <code>float | floating</code> <p>The estimated error norm.</p> required <code>ndarray</code> <p>The model output including non-identified outputs.</p> required <code>ICMethods</code> <p>Method used of to attribute a performance to the model</p> <code>'AIC'</code> References <p>https://ieeexplore.ieee.org/abstract/document/8516791</p>"},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.Armax(G)","title":"<code>G</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.Armax(H)","title":"<code>H</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.Armax(order_bounds)","title":"<code>order_bounds</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.Armax(Vn)","title":"<code>Vn</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.Armax(y_id)","title":"<code>y_id</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.Armax(method)","title":"<code>method</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_MISO_id","title":"ARX_MISO_id","text":"<pre><code>ARX_MISO_id(\n    y: ndarray,\n    u: ndarray,\n    na: int,\n    nb: ndarray,\n    theta: ndarray,\n) -&gt; tuple[\n    ndarray, ndarray, ndarray, ndarray, floating, ndarray\n]\n</code></pre> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p> <p>Identified through the computation of the pseudo-inverse of the regressor matrix ($ \\phi $).</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>Measured data</p> required <code>ndarray</code> <p>Input data</p> required <code>int</code> <p>Order of the autoregressive part.</p> required <code>ndarray</code> <p>Order of the exogenous part.</p> required <code>ndarray</code> <p>Delay of the exogenous part.</p> required <p>Returns:</p> Name Type Description <code>numerator</code> <code>ndarray</code> <code>denominator</code> <code>ndarray</code> <code>numerator_h</code> <code>ndarray</code> <code>denominator_h</code> <code>ndarray</code> <code>Vn</code> <code>floating</code> <p>The estimated error norm.</p> <code>y_id</code> <code>ndarray</code> <p>The model output including non-identified outputs.</p>"},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_MISO_id(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_MISO_id(u)","title":"<code>u</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_MISO_id(na)","title":"<code>na</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_MISO_id(nb)","title":"<code>nb</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_MISO_id(theta)","title":"<code>theta</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id","title":"ARX_id","text":"<pre><code>ARX_id(\n    y: ndarray,\n    u: ndarray,\n    na: int,\n    nb: ndarray,\n    theta: ndarray,\n    y_std: float = 1.0,\n    U_std: ndarray = array(1.0),\n) -&gt; tuple[\n    ndarray, ndarray, ndarray, ndarray, floating, ndarray\n]\n</code></pre> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p> <p>Identified through the computation of the pseudo-inverse of the regressor matrix ($ \\phi $).</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>Measured data</p> required <code>ndarray</code> <p>Input data</p> required <code>int</code> <p>Order of the autoregressive part.</p> required <code>ndarray</code> <p>Order of the exogenous part.</p> required <code>ndarray</code> <p>Delay of the exogenous part.</p> required <code>float</code> <p>Standard deviation of the output data.</p> <code>1.0</code> <code>ndarray</code> <p>Standard deviation of the input data.</p> <code>array(1.0)</code> <p>Returns:</p> Name Type Description <code>numerator</code> <code>ndarray</code> <code>denominator</code> <code>ndarray</code> <code>numerator_h</code> <code>ndarray</code> <code>denominator_h</code> <code>ndarray</code> <code>Vn</code> <code>floating</code> <p>The estimated error norm.</p> <code>y_id</code> <code>ndarray</code> <p>The model output including non-identified outputs.</p>"},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id(u)","title":"<code>u</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id(na)","title":"<code>na</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id(nb)","title":"<code>nb</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id(theta)","title":"<code>theta</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id(y_std)","title":"<code>y_std</code>","text":""},{"location":"reference/sippy_unipi/io/#sippy_unipi.io.ARX_id(U_std)","title":"<code>U_std</code>","text":""},{"location":"reference/sippy_unipi/io/armax/","title":"armax","text":""},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax","title":"armax","text":"<p>Created on Fri Jul 28 2017</p> <p>@author: Giuseppe Armenise</p> <p>Classes:</p> Name Description <code>Armax</code>"},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax.Armax","title":"Armax","text":"<pre><code>Armax(\n    G: TransferFunction,\n    H: TransferFunction,\n    *order_bounds: tuple[int, int],\n    Vn: float | floating,\n    y_id: ndarray,\n    method: ICMethods = \"AIC\"\n)\n</code></pre> <p>The AutoRegressive-Moving-Average with eXogenous inputs model is computed based on a recursive lest-square regression between the input data (U) and the measured output data (Y). As Y is noisy in practice, a white noise (E) is identified within the model. This model is designed to deal with potential time-delays between U and Y.</p> <p>SIPPY implements an iterative procedure, with   extit{iterative least-square regression} = <code>ILLS</code>.</p> <p>The following equations summarize the equations involved in the model:</p> <p>$$ Y = G.U + H.E</p> <p>G = B / A H = C / A</p> <p>A = 1 + a_1z^(-1) + ... + a_naz^(-na) B = b_1z^(-1-theta) + ... + b_nbz^(-nb-theta) C = c_1z^(-1) + ... + c_ncz^(-nc) $$</p> <p>Parameters:</p> Name Type Description Default <code>TransferFunction</code> <p>output response</p> required <code>TransferFunction</code> <p>noise response</p> required <code>tuple[int, int]</code> <p>extended range of the order of: - na_bounds: the common denominator - nb_bounds: the G numerator - nc_bounds: the H numerator - theta_bounds: the discrete theta in B</p> <code>()</code> <code>float | floating</code> <p>The estimated error norm.</p> required <code>ndarray</code> <p>The model output including non-identified outputs.</p> required <code>ICMethods</code> <p>Method used of to attribute a performance to the model</p> <code>'AIC'</code> References <p>https://ieeexplore.ieee.org/abstract/document/8516791</p>"},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax.Armax(G)","title":"<code>G</code>","text":""},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax.Armax(H)","title":"<code>H</code>","text":""},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax.Armax(order_bounds)","title":"<code>order_bounds</code>","text":""},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax.Armax(Vn)","title":"<code>Vn</code>","text":""},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax.Armax(y_id)","title":"<code>y_id</code>","text":""},{"location":"reference/sippy_unipi/io/armax/#sippy_unipi.io.armax.Armax(method)","title":"<code>method</code>","text":""},{"location":"reference/sippy_unipi/io/arx/","title":"arx","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx","title":"arx","text":"<p>Created on Wed Jul 26 2017</p> <p>@author: Giuseppe Armenise</p> <p>Functions:</p> Name Description <code>ARX_MISO_id</code> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p> <code>ARX_id</code> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p> <code>compute_num_den</code> <p>Compute the numerator and denominator coefficients.</p> <code>compute_phi</code> <p>Compute the regressor matrix PHI.</p> <code>compute_theta</code> <p>Computes the parameter vector THETA, the model output y_id, and the estimated error norm Vn.</p>"},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_MISO_id","title":"ARX_MISO_id","text":"<pre><code>ARX_MISO_id(\n    y: ndarray,\n    u: ndarray,\n    na: int,\n    nb: ndarray,\n    theta: ndarray,\n) -&gt; tuple[\n    ndarray, ndarray, ndarray, ndarray, floating, ndarray\n]\n</code></pre> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p> <p>Identified through the computation of the pseudo-inverse of the regressor matrix ($ \\phi $).</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>Measured data</p> required <code>ndarray</code> <p>Input data</p> required <code>int</code> <p>Order of the autoregressive part.</p> required <code>ndarray</code> <p>Order of the exogenous part.</p> required <code>ndarray</code> <p>Delay of the exogenous part.</p> required <p>Returns:</p> Name Type Description <code>numerator</code> <code>ndarray</code> <code>denominator</code> <code>ndarray</code> <code>numerator_h</code> <code>ndarray</code> <code>denominator_h</code> <code>ndarray</code> <code>Vn</code> <code>floating</code> <p>The estimated error norm.</p> <code>y_id</code> <code>ndarray</code> <p>The model output including non-identified outputs.</p>"},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_MISO_id(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_MISO_id(u)","title":"<code>u</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_MISO_id(na)","title":"<code>na</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_MISO_id(nb)","title":"<code>nb</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_MISO_id(theta)","title":"<code>theta</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id","title":"ARX_id","text":"<pre><code>ARX_id(\n    y: ndarray,\n    u: ndarray,\n    na: int,\n    nb: ndarray,\n    theta: ndarray,\n    y_std: float = 1.0,\n    U_std: ndarray = array(1.0),\n) -&gt; tuple[\n    ndarray, ndarray, ndarray, ndarray, floating, ndarray\n]\n</code></pre> <p>Auto-Regressive with eXogenous Inputs model (ARX) identification.</p> <p>Identified through the computation of the pseudo-inverse of the regressor matrix ($ \\phi $).</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>Measured data</p> required <code>ndarray</code> <p>Input data</p> required <code>int</code> <p>Order of the autoregressive part.</p> required <code>ndarray</code> <p>Order of the exogenous part.</p> required <code>ndarray</code> <p>Delay of the exogenous part.</p> required <code>float</code> <p>Standard deviation of the output data.</p> <code>1.0</code> <code>ndarray</code> <p>Standard deviation of the input data.</p> <code>array(1.0)</code> <p>Returns:</p> Name Type Description <code>numerator</code> <code>ndarray</code> <code>denominator</code> <code>ndarray</code> <code>numerator_h</code> <code>ndarray</code> <code>denominator_h</code> <code>ndarray</code> <code>Vn</code> <code>floating</code> <p>The estimated error norm.</p> <code>y_id</code> <code>ndarray</code> <p>The model output including non-identified outputs.</p>"},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id(u)","title":"<code>u</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id(na)","title":"<code>na</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id(nb)","title":"<code>nb</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id(theta)","title":"<code>theta</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id(y_std)","title":"<code>y_std</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.ARX_id(U_std)","title":"<code>U_std</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den","title":"compute_num_den","text":"<pre><code>compute_num_den(\n    THETA: ndarray,\n    na: int,\n    nb: ndarray,\n    theta: ndarray,\n    val: int,\n    udim: int = 1,\n    y_std: ndarray | float = 1.0,\n    U_std: ndarray | float = array(1.0),\n) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Compute the numerator and denominator coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>Coefficient vector.</p> required <code>int</code> <p>Order of the autoregressive part.</p> required <code>ndarray</code> <p>Order of the exogenous part.</p> required <code>ndarray</code> <p>Delay of the exogenous part.</p> required <code>int</code> <p>Maximum predictable order.</p> required <code>int</code> <p>Dimension of the input data.</p> <code>1</code> <code>ndarray | float</code> <p>Standard deviation of the output data.</p> <code>1.0</code> <code>ndarray | float</code> <p>Standard deviation of the input data.</p> <code>array(1.0)</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[ndarray, ndarray]</code> <p>Denominator coefficients, numerator coefficients, and numerator_h.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; THETA = np.array([0.5, -0.2, 0.3, 0.1])\n&gt;&gt;&gt; na = 2\n&gt;&gt;&gt; nb = np.array([2])\n&gt;&gt;&gt; theta = np.array([1])\n&gt;&gt;&gt; val = 3\n&gt;&gt;&gt; udim = 1\n&gt;&gt;&gt; compute_num_den(THETA, na, nb, theta, val, udim)\n(array([0. , 0.3, 0.1]), array([ 1. ,  0.5, -0.2,  0. ]))\n</code></pre> <pre><code>&gt;&gt;&gt; THETA = np.array([0.5, -0.2, 0.3, 0.1, 0.4, 0.2])\n&gt;&gt;&gt; na = 2\n&gt;&gt;&gt; nb = np.array([2, 2])\n&gt;&gt;&gt; theta = np.array([1, 1])\n&gt;&gt;&gt; val = 3\n&gt;&gt;&gt; udim = 2\n&gt;&gt;&gt; compute_num_den(THETA, na, nb, theta, val, udim, y_std=1, U_std=[1.0, 1.0])\n(array([[0. , 0.3, 0.1],\n    [0. , 0.4, 0.2]]), array([[ 1. ,  0.5, -0.2,  0. ],\n    [ 1. ,  0.5, -0.2,  0. ]]))\n</code></pre>"},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(THETA)","title":"<code>THETA</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(na)","title":"<code>na</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(nb)","title":"<code>nb</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(theta)","title":"<code>theta</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(val)","title":"<code>val</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(udim)","title":"<code>udim</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(y_std)","title":"<code>y_std</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_num_den(U_std)","title":"<code>U_std</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi","title":"compute_phi","text":"<pre><code>compute_phi(\n    y: ndarray,\n    u: ndarray,\n    na: int,\n    nb: ndarray,\n    theta: ndarray,\n    val: int,\n    N: int,\n    udim: int = 1,\n) -&gt; ndarray\n</code></pre> <p>Compute the regressor matrix PHI.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>Output data.</p> required <code>ndarray</code> <p>Input data.</p> required <code>int</code> <p>Order of the autoregressive part.</p> required <code>ndarray</code> <p>Order of the exogenous part.</p> required <code>ndarray</code> <p>Delay of the exogenous part.</p> required <code>int</code> <p>Maximum predictable order.</p> required <code>int</code> <p>Number of data points.</p> required <code>int</code> <p>Dimension of the input data.</p> <code>1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Regressor matrix PHI.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; y = np.array([1, 2, 3, 4, 5])\n&gt;&gt;&gt; u = np.array([1, 2, 3, 4, 5])\n&gt;&gt;&gt; na = 2\n&gt;&gt;&gt; nb = np.array([2])\n&gt;&gt;&gt; theta = np.array([1])\n&gt;&gt;&gt; val = 2\n&gt;&gt;&gt; N = 3\n&gt;&gt;&gt; compute_phi(y, u, na, nb, theta, val, N, udim=1)\narray([[-2., -1.,  2.,  1.],\n    [-3., -2.,  3.,  2.],\n    [-4., -3.,  4.,  3.]])\n</code></pre> <pre><code>&gt;&gt;&gt; y = np.array([1, 2, 3, 4, 5])\n&gt;&gt;&gt; u = np.array([[1, 2, 3, 4, 5], [5, 4, 3, 2, 1]])\n&gt;&gt;&gt; na = 2\n&gt;&gt;&gt; nb = np.array([2, 2])\n&gt;&gt;&gt; theta = np.array([1, 1])\n&gt;&gt;&gt; val = 2\n&gt;&gt;&gt; N = 3\n&gt;&gt;&gt; compute_phi(y, u, na, nb, theta, val, N, udim=2)\narray([[-2., -1.,  1.,  1.,  5.,  5.],\n    [-3., -2.,  2.,  1.,  4.,  5.],\n    [-4., -3.,  3.,  2.,  3.,  4.]])\n</code></pre>"},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(u)","title":"<code>u</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(na)","title":"<code>na</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(nb)","title":"<code>nb</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(theta)","title":"<code>theta</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(val)","title":"<code>val</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(N)","title":"<code>N</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_phi(udim)","title":"<code>udim</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_theta","title":"compute_theta","text":"<pre><code>compute_theta(\n    PHI: ndarray, y: ndarray, val: int, y_std=1.0\n) -&gt; tuple[ndarray, ndarray, floating]\n</code></pre> <p>Computes the parameter vector THETA, the model output y_id, and the estimated error norm Vn.</p> <p>Parameters:</p> Name Type Description Default <code>ndarray</code> <p>The regression matrix.</p> required <code>ndarray</code> <p>The output vector.</p> required <code>int</code> <p>The index from which to start the validation.</p> required <p>Returns:</p> Name Type Description <code>THETA</code> <code>ndarray</code> <p>The parameter vector.</p> <code>y_id</code> <code>ndarray</code> <p>The model output including non-identified outputs.</p> <code>Vn</code> <code>floating</code> <p>The estimated error norm.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; PHI = np.array([[1, 2], [3, 4], [5, 6]])\n&gt;&gt;&gt; y = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; val = 1\n&gt;&gt;&gt; THETA, y_id, Vn = compute_theta(PHI, y, val)\n&gt;&gt;&gt; THETA\narray([-1. ,  1.5])\n&gt;&gt;&gt; y_id\narray([1., 2., 3., 4.])\n&gt;&gt;&gt; round(Vn, 6)\nnp.float64(0.0)\n</code></pre>"},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_theta(PHI)","title":"<code>PHI</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_theta(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/io/arx/#sippy_unipi.io.arx.compute_theta(val)","title":"<code>val</code>","text":""},{"location":"reference/sippy_unipi/io/base/","title":"base","text":""},{"location":"reference/sippy_unipi/io/base/#sippy_unipi.io.base","title":"base","text":"<p>Helper functions for nonlinear optimization problem used by some of the identification functions.</p> <p>@author: RBdC &amp; MV</p>"},{"location":"reference/sippy_unipi/io/opt/","title":"opt","text":""},{"location":"reference/sippy_unipi/io/opt/#sippy_unipi.io.opt","title":"opt","text":"<p>Created on 2021</p> <p>@author: RBdC &amp; MV</p> <p>Functions:</p> Name Description <code>GEN_id</code> <p>Identification using non-linear regression.</p>"},{"location":"reference/sippy_unipi/io/opt/#sippy_unipi.io.opt.GEN_id","title":"GEN_id","text":"<pre><code>GEN_id(\n    y: ndarray,\n    u: ndarray,\n    id_method: OptMethods,\n    na: int,\n    nb: int | ndarray,\n    nc: int,\n    nd: int,\n    nf: int,\n    theta: int | ndarray,\n    max_iter: int,\n    stab_marg: float,\n    stab_cons: bool,\n    adjust_B: bool = False,\n    y_std: float = 1.0,\n    U_std: ndarray = array([1.0]),\n) -&gt; tuple[\n    ndarray, ndarray, ndarray, ndarray, floating, ndarray\n]\n</code></pre> <p>Identification using non-linear regression.</p> <p>Use Prediction Error Method and non-linear regression, due to the nonlinear effect of the parameter vector ($ \\Theta $) to be identified in the regressor matrix $ \\phi(\\Theta) $.</p> <p>These structures are identified by solving a NonLinear Program by the use of the  extbf{CasADi} optimization tool.</p> References <p>Andersson, J. A.E., Gillis, J., Horn, G., Rawlings, J.B. and Diehl, M. {CasADi}: a software framework for nonlinear optimization and optimal control. 2019.</p>"},{"location":"reference/sippy_unipi/io/rls/","title":"rls","text":""},{"location":"reference/sippy_unipi/io/rls/#sippy_unipi.io.rls","title":"rls","text":"<p>Created on 2021</p> <p>@author: RBdC &amp; MV</p> <p>Functions:</p> Name Description <code>GEN_RLS_id</code> <p>Identification using Recursive Least-Squares Regression.</p>"},{"location":"reference/sippy_unipi/io/rls/#sippy_unipi.io.rls.GEN_RLS_id","title":"GEN_RLS_id","text":"<pre><code>GEN_RLS_id(\n    y: ndarray,\n    u: ndarray,\n    id_method: RLSMethods,\n    na: int,\n    nb: int | ndarray,\n    nc: int,\n    nd: int,\n    nf: int,\n    theta: int | ndarray,\n    **_\n) -&gt; tuple[\n    ndarray, ndarray, ndarray, ndarray, float, ndarray\n]\n</code></pre> <p>Identification using Recursive Least-Squares Regression.</p> <p>A gain estimator, a covariance matrix and a suitable Forgetting Factor are computed.</p>"},{"location":"reference/sippy_unipi/ss/","title":"Index","text":""},{"location":"reference/sippy_unipi/ss/#sippy_unipi.ss","title":"ss","text":"<p>State-Space Models</p> <p>Modules:</p> Name Description <code>base</code> <p>Helper functions used by the Subspace Identification Methods and other useful functions for State Space models.</p> <code>olsim</code> <p>Created on Thu Oct 12 2017</p> <code>parsim</code> <p>Created on Sat Nov 04 2017</p> <p>Functions:</p> Name Description <code>lsim_process_form</code> <p>Simulate system in a process form.</p>"},{"location":"reference/sippy_unipi/ss/#sippy_unipi.ss.lsim_process_form","title":"lsim_process_form","text":"<pre><code>lsim_process_form(\n    A: ndarray,\n    B: ndarray,\n    C: ndarray,\n    D: ndarray,\n    u: ndarray,\n    x0: ndarray | None = None,\n)\n</code></pre> <p>Simulate system in a process form.</p> <p>This function performs a simulation in the process form, given the identified system matrices, the input sequence (an array with \\(n_u\\) rows and L columns) and the initial state estimate (array with \\(n\\) rows and one column).</p>"},{"location":"reference/sippy_unipi/ss/base/","title":"base","text":""},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base","title":"base","text":"<p>Helper functions used by the Subspace Identification Methods and other useful functions for State Space models.</p> <p>@author: Giuseppe Armenise</p> <p>Functions:</p> Name Description <code>Vn_mat</code> <p>Compute the variance of the model residuals</p> <code>Z_dot_PIort</code> <p>Compute the scalar product between a vector z and \\(I - x^T \\cdot pinv(X^T)\\), avoiding the direct computation of the matrix</p> <code>lsim_innovation_form</code> <p>Simulate system in a innovation form.</p> <code>lsim_predictor_form</code> <p>Simulate system in a predictor form.</p> <code>lsim_process_form</code> <p>Simulate system in a process form.</p>"},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.Vn_mat","title":"Vn_mat","text":"<pre><code>Vn_mat(y: ndarray, yest: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the variance of the model residuals</p> <p>Parameters:</p> Name Type Description Default <p>(L*l,1) vectorized matrix of output of the process</p> required <p>(L*l,1) vectorized matrix of output of the estimated model</p> required"},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.Vn_mat(y)","title":"<code>y</code>","text":""},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.Vn_mat(yest)","title":"<code>yest</code>","text":""},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.Z_dot_PIort","title":"Z_dot_PIort","text":"<pre><code>Z_dot_PIort(z: ndarray, X: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the scalar product between a vector z and \\(I - x^T \\cdot pinv(X^T)\\), avoiding the direct computation of the matrix</p> <p>PI = np.dot(X.T, np.linalg.pinv(X.T)), causing high memory usage</p> <p>Parameters:</p> Name Type Description Default <p>(...) vector array_like</p> required <p>(...) matrix array_like</p> required"},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.Z_dot_PIort(z)","title":"<code>z</code>","text":""},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.Z_dot_PIort(X)","title":"<code>X</code>","text":""},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.lsim_innovation_form","title":"lsim_innovation_form","text":"<pre><code>lsim_innovation_form(\n    A: ndarray,\n    B: ndarray,\n    C: ndarray,\n    D: ndarray,\n    K: ndarray,\n    y: ndarray,\n    u: ndarray,\n    x0: ndarray | None = None,\n)\n</code></pre> <p>Simulate system in a innovation form.</p> <p>This function performs a simulation in the innovation form. This function is analogous to the previous one, using the system matrices $ A $ and $ B $ instead of $ A_K $ and $ B_K $</p>"},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.lsim_predictor_form","title":"lsim_predictor_form","text":"<pre><code>lsim_predictor_form(\n    A_K: ndarray,\n    B_K: ndarray,\n    C: ndarray,\n    D: ndarray,\n    K: ndarray,\n    y: ndarray,\n    u: ndarray,\n    x0: ndarray | None = None,\n)\n</code></pre> <p>Simulate system in a predictor form.</p> <p>This function performs a simulation in the predictor form, given the identified system matrices, the Kalman filter gain, the real output sequence (array with \\(n_y\\) rows and L columns, the input sequence (an array with \\(n_u\\) rows and L columns) and the initial state estimate (array with \\(n\\) rows and one column). The state sequence and the estimated output sequence are returned.</p>"},{"location":"reference/sippy_unipi/ss/base/#sippy_unipi.ss.base.lsim_process_form","title":"lsim_process_form","text":"<pre><code>lsim_process_form(\n    A: ndarray,\n    B: ndarray,\n    C: ndarray,\n    D: ndarray,\n    u: ndarray,\n    x0: ndarray | None = None,\n)\n</code></pre> <p>Simulate system in a process form.</p> <p>This function performs a simulation in the process form, given the identified system matrices, the input sequence (an array with \\(n_u\\) rows and L columns) and the initial state estimate (array with \\(n\\) rows and one column).</p>"},{"location":"reference/sippy_unipi/ss/olsim/","title":"olsim","text":""},{"location":"reference/sippy_unipi/ss/olsim/#sippy_unipi.ss.olsim","title":"olsim","text":"<p>Created on Thu Oct 12 2017</p> <p>@author: Giuseppe Armenise</p>"},{"location":"reference/sippy_unipi/ss/parsim/","title":"parsim","text":""},{"location":"reference/sippy_unipi/ss/parsim/#sippy_unipi.ss.parsim","title":"parsim","text":"<p>Created on Sat Nov 04 2017</p> <p>@author: Giuseppe Armenise</p>"},{"location":"reference/sippy_unipi/tf2ss/","title":"Index","text":""},{"location":"reference/sippy_unipi/tf2ss/#sippy_unipi.tf2ss","title":"tf2ss","text":"<p>Convert your MISO/SIMO/MIMO systems from transfer function to state-space.</p> <p>Modules:</p> Name Description <code>test_tf2ss</code> <p>Tests of tf2ss on various sample systems and consistency with SLYCOT.</p> <code>tf2ss</code> <p>Helper functions for tf2ss conversion.</p> <code>timeresp</code> <p>Functions:</p> Name Description <code>forced_response</code> <p>Compute the output of a linear system given the input.</p>"},{"location":"reference/sippy_unipi/tf2ss/#sippy_unipi.tf2ss.forced_response","title":"forced_response","text":"<pre><code>forced_response(\n    sysdata,\n    T=None,\n    U=0.0,\n    X0=0.0,\n    transpose=False,\n    params=None,\n    interpolate=False,\n    return_x: bool = None,\n    squeeze=None,\n)\n</code></pre> <p>Compute the output of a linear system given the input.</p> <p>As a convenience for parameters <code>U</code>, <code>X0</code>: Numbers (scalars) are converted to constant arrays with the correct shape. The correct shape is inferred from arguments <code>sys</code> and <code>T</code>.</p> <p>For information on the shape of parameters <code>U</code>, <code>T</code>, <code>X0</code> and return values <code>T</code>, <code>yout</code>, <code>xout</code>, see :ref:<code>time-series-convention</code>.</p>"},{"location":"reference/sippy_unipi/tf2ss/#sippy_unipi.tf2ss.forced_response--parameters","title":"Parameters","text":"<p>sysdata : I/O system or list of I/O systems     I/O system(s) for which forced response is computed.</p> array_like, optional for discrete LTI <code>sys</code> <p>Time steps at which the input is defined; values must be evenly spaced.</p> <p>If None, <code>U</code> must be given and <code>len(U)</code> time steps of sys.dt are simulated. If sys.dt is None or True (undetermined time step), a time step of 1.0 is assumed.</p> array_like or float, optional <p>Input array giving input at each time <code>T</code>. If <code>U</code> is None or 0, <code>T</code> must be given, even for discrete time systems. In this case, for continuous time systems, a direct calculation of the matrix exponential is used, which is faster than the general interpolating algorithm used otherwise.</p> array_like or float, default=0. <p>Initial condition.</p> dict, optional <p>If system is a nonlinear I/O system, set parameter values.</p> bool, default=False <p>If True, transpose all input and output arrays (for backward compatibility with MATLAB and :func:<code>scipy.signal.lsim</code>).</p> bool, default=False <p>If True and system is a discrete time system, the input will be interpolated between the given time steps and the output will be given at system sampling rate.  Otherwise, only return the output at the times given in <code>T</code>.  No effect on continuous time simulations.</p> bool, default=None <p>Used if the time response data is assigned to a tuple:</p> <ul> <li> <p>If False, return only the time and output vectors.</p> </li> <li> <p>If True, also return the the state vector.</p> </li> <li> <p>If None, determine the returned variables by   config.defaults['forced_response.return_x'], which was True   before version 0.9 and is False since then.</p> </li> </ul> bool, optional <p>By default, if a system is single-input, single-output (SISO) then the output response is returned as a 1D array (indexed by time).  If <code>squeeze</code> is True, remove single-dimensional entries from the shape of the output even if the system is not SISO. If <code>squeeze</code> is False, keep the output as a 2D array (indexed by the output number and time) even if the system is SISO. The default behavior can be overridden by config.defaults['control.squeeze_time_response'].</p>"},{"location":"reference/sippy_unipi/tf2ss/#sippy_unipi.tf2ss.forced_response--returns","title":"Returns","text":"<p>results : :class:<code>TimeResponseData</code> or :class:<code>TimeResponseList</code>     Time response represented as a :class:<code>TimeResponseData</code> object or     list of :class:<code>TimeResponseData</code> objects containing the following     properties:</p> <pre><code>* time (array): Time values of the output.\n\n* outputs (array): Response of the system.  If the system is SISO and\n  `squeeze` is not True, the array is 1D (indexed by time).  If the\n  system is not SISO or `squeeze` is False, the array is 2D (indexed\n  by output and time).\n\n* states (array): Time evolution of the state vector, represented as\n  a 2D array indexed by state and time.\n\n* inputs (array): Input(s) to the system, indexed by input and time.\n\nThe `plot()` method can be used to create a plot of the time\nresponse(s) (see :func:`time_response_plot` for more information).\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/#sippy_unipi.tf2ss.forced_response--see-also","title":"See Also","text":"<p>step_response, initial_response, impulse_response, input_output_response</p>"},{"location":"reference/sippy_unipi/tf2ss/#sippy_unipi.tf2ss.forced_response--notes","title":"Notes","text":"<ol> <li> <p>For discrete time systems, the input/output response is computed    using the :func:<code>scipy.signal.dlsim</code> function.</p> </li> <li> <p>For continuous time systems, the output is computed using the matrix    exponential <code>exp(A t)</code> and assuming linear interpolation of the    inputs between time points.</p> </li> <li> <p>If a nonlinear I/O system is passed to <code>forced_response</code>, the    <code>input_output_response</code> function is called instead.  The main    difference between <code>input_output_response</code> and <code>forced_response</code> is    that <code>forced_response</code> is specialized (and optimized) for linear    systems.</p> </li> </ol>"},{"location":"reference/sippy_unipi/tf2ss/test_tf2ss/","title":"test_tf2ss","text":""},{"location":"reference/sippy_unipi/tf2ss/test_tf2ss/#sippy_unipi.tf2ss.test_tf2ss","title":"test_tf2ss","text":"<p>Tests of tf2ss on various sample systems and consistency with SLYCOT.</p>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/","title":"tf2ss","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss","title":"tf2ss","text":"<p>Helper functions for tf2ss conversion.</p> <p>Functions:</p> Name Description <code>compute_adjusted_num</code> <p>Compute the adjusted numerator polynomial coefficients given the numerator and denominator</p> <code>compute_lcd_from_denominators</code> <p>Compute the least common denominator (LCD) of a MIMO system's denominators.</p> <code>controllable_canonical_form</code> <p>Compute the controllable canonical form (A, B) matrices for a given common denominator polynomial.</p> <code>list_to_poly</code> <p>Convert a list of coefficients (in descending order) into a sympy Poly.</p> <code>rjust</code> <p>Examples:</p> <code>state_space_from_poly</code> <p>Compute the state-space representation (A, B) from the denominator polynomial using tf2ss.</p> <code>tf2ss</code> <p>Convert a MIMO transfer function to a minimal state-space realization.</p> <code>transpose</code> <p>Transpose a list of lists (matrix).</p>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_adjusted_num","title":"compute_adjusted_num","text":"<pre><code>compute_adjusted_num(\n    numerator: list[Any],\n    lcd: Poly,\n    denominator: list[Any],\n    s: Symbol = Symbol(\"s\"),\n) -&gt; list[Any]\n</code></pre> <p>Compute the adjusted numerator polynomial coefficients given the numerator and denominator of a transfer function and the common LCD.</p> <p>This function multiplies the original numerator by the LCD and divides by the original denominator. The resulting quotient (assumed to be exact) gives the adjusted numerator.</p> <p>Parameters:</p> Name Type Description Default <code>list[Any]</code> <p>List of numerator coefficients (in descending order).</p> required <code>Poly</code> <p>A sympy Poly representing the least common denominator.</p> required <code>list[Any]</code> <p>List of denominator coefficients (in descending order).</p> required <code>Symbol</code> <p>sympy symbol (default is s).</p> <code>Symbol('s')</code> <p>Returns:</p> Type Description <code>list[Any]</code> <p>A numpy array of adjusted numerator coefficients (in descending order).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; compute_adjusted_num([1, 1], list_to_poly([1, 3, 2]), [1, 3, 2])\n[1, 1]\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_adjusted_num(numerator)","title":"<code>numerator</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_adjusted_num(lcd)","title":"<code>lcd</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_adjusted_num(denominator)","title":"<code>denominator</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_adjusted_num(s)","title":"<code>s</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_lcd_from_denominators","title":"compute_lcd_from_denominators","text":"<pre><code>compute_lcd_from_denominators(\n    denominators: list[list[list[float]]],\n    s: Symbol = Symbol(\"s\"),\n) -&gt; Poly\n</code></pre> <p>Compute the least common denominator (LCD) of a MIMO system's denominators.</p> <p>Parameters:</p> Name Type Description Default <code>list[list[list[float]]]</code> <p>A list of lists of denominators. Each denominator is a list of coefficients         in descending order.</p> required <code>Symbol</code> <p>sympy symbol (default is s).</p> <code>Symbol('s')</code> <p>Returns:</p> Type Description <code>Poly</code> <p>A sympy Poly representing the LCD.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lcd = compute_lcd_from_denominators([[[1, 2]], [[1, 2]]])\n&gt;&gt;&gt; sp.expand(lcd.as_expr())\ns + 2\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_lcd_from_denominators(denominators)","title":"<code>denominators</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.compute_lcd_from_denominators(s)","title":"<code>s</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.controllable_canonical_form","title":"controllable_canonical_form","text":"<pre><code>controllable_canonical_form(\n    denominator: list[float] | Poly,\n) -&gt; tuple[NDArray, NDArray]\n</code></pre> <p>Compute the controllable canonical form (A, B) matrices for a given common denominator polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>list</code> <p>Coefficients of the denominator polynomial [a_n, ..., a_1, a_0],                 where the highest-degree term is first.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[NDArray, NDArray]</code> <p>(A, B) state-space representation in controllable canonical form.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; controllable_canonical_form([1, 2, 3])\n(array([[ 0.,  1.],\n    [-2., -3.]]), array([[0.],\n    [1.]]))\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.controllable_canonical_form(denominator)","title":"<code>denominator</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.list_to_poly","title":"list_to_poly","text":"<pre><code>list_to_poly(\n    coefs: list[Any], s: Symbol = Symbol(\"s\")\n) -&gt; Poly\n</code></pre> <p>Convert a list of coefficients (in descending order) into a sympy Poly.</p> <p>Parameters:</p> Name Type Description Default <code>list[Any]</code> <p>List of coefficients (descending order).      For example, [1, 3, 2] represents 1s2 + 3s + 2.</p> required <code>Symbol</code> <p>sympy symbol (default is s).</p> <code>Symbol('s')</code> <p>Returns:</p> Type Description <code>Poly</code> <p>A sympy Poly object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = list_to_poly([1, 3, 2])\n&gt;&gt;&gt; sp.expand(p.as_expr())\ns**2 + 3*s + 2\n&gt;&gt;&gt; sp.expand(p.as_expr()) == sp.expand(sp.Symbol('s')**2 + 3*sp.Symbol('s') + 2)\nTrue\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.list_to_poly(coefs)","title":"<code>coefs</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.list_to_poly(s)","title":"<code>s</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.rjust","title":"rjust","text":"<pre><code>rjust(list_: list[int | float], width) -&gt; list[int | float]\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rjust([1, 2, 3], 4)\n[1, 2, 3, 0]\n&gt;&gt;&gt; rjust([1, 2, 3, 4, 5], 4)\n[1, 2, 3, 4]\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.state_space_from_poly","title":"state_space_from_poly","text":"<pre><code>state_space_from_poly(\n    poly: Poly,\n) -&gt; tuple[NDArray, NDArray]\n</code></pre> <p>Compute the state-space representation (A, B) from the denominator polynomial using tf2ss.</p> <p>Parameters:</p> Name Type Description Default <code>Poly</code> <p>A sympy Poly representing the denominator.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray]</code> <p>A, B: Matrices from the tf2ss representation of the system with transfer function 1/poly.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; A, B = state_space_from_poly(list_to_poly([1, 2]))\n&gt;&gt;&gt; A.shape\n(1, 1)\n&gt;&gt;&gt; B.shape\n(1, 1)\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.state_space_from_poly(poly)","title":"<code>poly</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.tf2ss","title":"tf2ss","text":"<pre><code>tf2ss(\n    sys: TransferFunction, minreal: bool = True\n) -&gt; tuple[NDArray, NDArray, NDArray, NDArray]\n</code></pre><pre><code>tf2ss(\n    numerators: list[list[list[int | float]]],\n    denominators: list[list[list[int | float]]],\n    minreal: bool = True,\n) -&gt; tuple[NDArray, NDArray, NDArray, NDArray]\n</code></pre> <pre><code>tf2ss(\n    *args: TransferFunction | list[list[list[int | float]]],\n    minreal: bool = True\n) -&gt; tuple[NDArray, NDArray, NDArray, NDArray]\n</code></pre> <p>Convert a MIMO transfer function to a minimal state-space realization.</p> <p>Parameters:</p> Name Type Description Default <code>TransferFunction | list[list[list[int | float]]]</code> <p>Either a single TransferFunction object or two lists (numerators and denominators).</p> <code>()</code> <code>bool</code> <p>Whether to perform minimal realization (default is True).</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[NDArray, NDArray, NDArray, NDArray]</code> <p>A, B, C, D: Minimal state-space matrices of the MIMO system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sys = TransferFunction([1], [1, 2])\n&gt;&gt;&gt; A, B, C, D = tf2ss(sys)\n&gt;&gt;&gt; A.shape[0] &gt; 0\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; numerators = [[[1]], [[1]]]\n&gt;&gt;&gt; denominators = [[[1, 2]], [[1, 2]]]\n&gt;&gt;&gt; A, B, C, D = tf2ss(numerators, denominators)\n&gt;&gt;&gt; A.shape[0] &gt; 0\nTrue\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.tf2ss(*args)","title":"<code>*args</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.tf2ss(minreal)","title":"<code>minreal</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.transpose","title":"transpose","text":"<pre><code>transpose(matrix: list[list[Any]]) -&gt; list[list[Any]]\n</code></pre> <p>Transpose a list of lists (matrix).</p> <p>Parameters:</p> Name Type Description Default <code>list[list[Any]]</code> <p>List of lists to be transposed.</p> required <p>Returns:</p> Type Description <code>list[list[Any]]</code> <p>Transposed list of lists.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose([[1, 2, 3], [4, 5, 6]])\n[[1, 4], [2, 5], [3, 6]]\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/tf2ss/#sippy_unipi.tf2ss.tf2ss.transpose(matrix)","title":"<code>matrix</code>","text":""},{"location":"reference/sippy_unipi/tf2ss/timeresp/","title":"timeresp","text":""},{"location":"reference/sippy_unipi/tf2ss/timeresp/#sippy_unipi.tf2ss.timeresp","title":"timeresp","text":"<p>Functions:</p> Name Description <code>forced_response</code> <p>Compute the output of a linear system given the input.</p>"},{"location":"reference/sippy_unipi/tf2ss/timeresp/#sippy_unipi.tf2ss.timeresp.forced_response","title":"forced_response","text":"<pre><code>forced_response(\n    sysdata,\n    T=None,\n    U=0.0,\n    X0=0.0,\n    transpose=False,\n    params=None,\n    interpolate=False,\n    return_x: bool = None,\n    squeeze=None,\n)\n</code></pre> <p>Compute the output of a linear system given the input.</p> <p>As a convenience for parameters <code>U</code>, <code>X0</code>: Numbers (scalars) are converted to constant arrays with the correct shape. The correct shape is inferred from arguments <code>sys</code> and <code>T</code>.</p> <p>For information on the shape of parameters <code>U</code>, <code>T</code>, <code>X0</code> and return values <code>T</code>, <code>yout</code>, <code>xout</code>, see :ref:<code>time-series-convention</code>.</p>"},{"location":"reference/sippy_unipi/tf2ss/timeresp/#sippy_unipi.tf2ss.timeresp.forced_response--parameters","title":"Parameters","text":"<p>sysdata : I/O system or list of I/O systems     I/O system(s) for which forced response is computed.</p> array_like, optional for discrete LTI <code>sys</code> <p>Time steps at which the input is defined; values must be evenly spaced.</p> <p>If None, <code>U</code> must be given and <code>len(U)</code> time steps of sys.dt are simulated. If sys.dt is None or True (undetermined time step), a time step of 1.0 is assumed.</p> array_like or float, optional <p>Input array giving input at each time <code>T</code>. If <code>U</code> is None or 0, <code>T</code> must be given, even for discrete time systems. In this case, for continuous time systems, a direct calculation of the matrix exponential is used, which is faster than the general interpolating algorithm used otherwise.</p> array_like or float, default=0. <p>Initial condition.</p> dict, optional <p>If system is a nonlinear I/O system, set parameter values.</p> bool, default=False <p>If True, transpose all input and output arrays (for backward compatibility with MATLAB and :func:<code>scipy.signal.lsim</code>).</p> bool, default=False <p>If True and system is a discrete time system, the input will be interpolated between the given time steps and the output will be given at system sampling rate.  Otherwise, only return the output at the times given in <code>T</code>.  No effect on continuous time simulations.</p> bool, default=None <p>Used if the time response data is assigned to a tuple:</p> <ul> <li> <p>If False, return only the time and output vectors.</p> </li> <li> <p>If True, also return the the state vector.</p> </li> <li> <p>If None, determine the returned variables by   config.defaults['forced_response.return_x'], which was True   before version 0.9 and is False since then.</p> </li> </ul> bool, optional <p>By default, if a system is single-input, single-output (SISO) then the output response is returned as a 1D array (indexed by time).  If <code>squeeze</code> is True, remove single-dimensional entries from the shape of the output even if the system is not SISO. If <code>squeeze</code> is False, keep the output as a 2D array (indexed by the output number and time) even if the system is SISO. The default behavior can be overridden by config.defaults['control.squeeze_time_response'].</p>"},{"location":"reference/sippy_unipi/tf2ss/timeresp/#sippy_unipi.tf2ss.timeresp.forced_response--returns","title":"Returns","text":"<p>results : :class:<code>TimeResponseData</code> or :class:<code>TimeResponseList</code>     Time response represented as a :class:<code>TimeResponseData</code> object or     list of :class:<code>TimeResponseData</code> objects containing the following     properties:</p> <pre><code>* time (array): Time values of the output.\n\n* outputs (array): Response of the system.  If the system is SISO and\n  `squeeze` is not True, the array is 1D (indexed by time).  If the\n  system is not SISO or `squeeze` is False, the array is 2D (indexed\n  by output and time).\n\n* states (array): Time evolution of the state vector, represented as\n  a 2D array indexed by state and time.\n\n* inputs (array): Input(s) to the system, indexed by input and time.\n\nThe `plot()` method can be used to create a plot of the time\nresponse(s) (see :func:`time_response_plot` for more information).\n</code></pre>"},{"location":"reference/sippy_unipi/tf2ss/timeresp/#sippy_unipi.tf2ss.timeresp.forced_response--see-also","title":"See Also","text":"<p>step_response, initial_response, impulse_response, input_output_response</p>"},{"location":"reference/sippy_unipi/tf2ss/timeresp/#sippy_unipi.tf2ss.timeresp.forced_response--notes","title":"Notes","text":"<ol> <li> <p>For discrete time systems, the input/output response is computed    using the :func:<code>scipy.signal.dlsim</code> function.</p> </li> <li> <p>For continuous time systems, the output is computed using the matrix    exponential <code>exp(A t)</code> and assuming linear interpolation of the    inputs between time points.</p> </li> <li> <p>If a nonlinear I/O system is passed to <code>forced_response</code>, the    <code>input_output_response</code> function is called instead.  The main    difference between <code>input_output_response</code> and <code>forced_response</code> is    that <code>forced_response</code> is specialized (and optimized) for linear    systems.</p> </li> </ol>"},{"location":"reference/sippy_unipi/utils/","title":"Index","text":""},{"location":"reference/sippy_unipi/utils/#sippy_unipi.utils","title":"utils","text":"<p>Helper functions and tools.</p> <p>Modules:</p> Name Description <code>base</code> <code>validation</code> <p>Functions:</p> Name Description <code>build_tfs</code> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p> <code>rescale</code> <p>Rescaling an array to its standard deviation.</p>"},{"location":"reference/sippy_unipi/utils/#sippy_unipi.utils.build_tfs","title":"build_tfs","text":"<pre><code>build_tfs(\n    THETA: ndarray,\n    na: int,\n    nb: ndarray,\n    nc: int,\n    nd: int,\n    nf: int,\n    theta: ndarray,\n    id_method: str,\n    udim: int,\n    y_std: float = 1.0,\n    U_std: ndarray = array([1.0]),\n) -&gt; tuple[ndarray, ndarray, ndarray, ndarray]\n</code></pre> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p>"},{"location":"reference/sippy_unipi/utils/#sippy_unipi.utils.rescale","title":"rescale","text":"<pre><code>rescale(y: ndarray) -&gt; tuple[float, ndarray]\n</code></pre> <p>Rescaling an array to its standard deviation.</p> <p>It gives the array rescaled as \\( y=\\frac{y}{\\mathrm{std}(y)} \\).</p>"},{"location":"reference/sippy_unipi/utils/base/","title":"base","text":""},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base","title":"base","text":"<p>Functions:</p> Name Description <code>build_polynomial</code> <p>Build a polynomial transfer function.</p> <code>build_tf_G</code> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p> <code>build_tf_H</code> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p> <code>build_tfs</code> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p> <code>rescale</code> <p>Rescaling an array to its standard deviation.</p>"},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base.build_polynomial","title":"build_polynomial","text":"<pre><code>build_polynomial(\n    order: int, coeffs: ndarray\n) -&gt; TransferFunction\n</code></pre> <p>Build a polynomial transfer function. This function constructs a transfer function of the form: H(s) = (s^order + 0s^(order-1) + ... + 0s + 1) / (s^order + coeffs[0]*s^(order-1) + ... + coeffs[order-1])</p> <p>Parameters:</p> Name Type Description Default <code>int</code> <p>The order of the polynomial.</p> required <code>ndarray</code> <p>The coefficients of the polynomial.</p> required <p>Returns:</p> Type Description <code>TransferFunction</code> <p>cnt.TransferFunction: The resulting transfer function.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the transfer function could not be obtained.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import control as cnt\n&gt;&gt;&gt; coeffs = np.array([1, 2, 3])\n&gt;&gt;&gt; tf = build_polynomial(3, coeffs)\n&gt;&gt;&gt; tf\nTransferFunction(array([1, 0, 0, 0]), array([1, 1, 2, 3]), 1)\n</code></pre>"},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base.build_polynomial(order)","title":"<code>order</code>","text":""},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base.build_polynomial(coeffs)","title":"<code>coeffs</code>","text":""},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base.build_tf_G","title":"build_tf_G","text":"<pre><code>build_tf_G(\n    THETA: ndarray,\n    na: int,\n    nb: ndarray,\n    nc: int,\n    nd: int,\n    nf: int,\n    theta: ndarray,\n    id_method: str,\n    udim: int,\n    y_std: float = 1.0,\n    U_std: ndarray = array([1.0]),\n) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p>"},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base.build_tf_H","title":"build_tf_H","text":"<pre><code>build_tf_H(\n    THETA: ndarray,\n    na: int,\n    nb: ndarray,\n    nc: int,\n    nd: int,\n    _: int,\n    __: ndarray,\n    id_method: str,\n    ___: int,\n) -&gt; tuple[ndarray, ndarray]\n</code></pre> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p>"},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base.build_tfs","title":"build_tfs","text":"<pre><code>build_tfs(\n    THETA: ndarray,\n    na: int,\n    nb: ndarray,\n    nc: int,\n    nd: int,\n    nf: int,\n    theta: ndarray,\n    id_method: str,\n    udim: int,\n    y_std: float = 1.0,\n    U_std: ndarray = array([1.0]),\n) -&gt; tuple[ndarray, ndarray, ndarray, ndarray]\n</code></pre> <p>Construct numerator, denominator, numerator_h, denominator_h from parameters.</p>"},{"location":"reference/sippy_unipi/utils/base/#sippy_unipi.utils.base.rescale","title":"rescale","text":"<pre><code>rescale(y: ndarray) -&gt; tuple[float, ndarray]\n</code></pre> <p>Rescaling an array to its standard deviation.</p> <p>It gives the array rescaled as \\( y=\\frac{y}{\\mathrm{std}(y)} \\).</p>"},{"location":"reference/sippy_unipi/utils/validation/","title":"validation","text":""},{"location":"reference/sippy_unipi/utils/validation/#sippy_unipi.utils.validation","title":"validation","text":"<p>Functions:</p> Name Description <code>validate_and_prepare_inputs</code> <p>Check input dimensions and ensure nb/theta are arrays.</p>"},{"location":"reference/sippy_unipi/utils/validation/#sippy_unipi.utils.validation.validate_and_prepare_inputs","title":"validate_and_prepare_inputs","text":"<pre><code>validate_and_prepare_inputs(\n    u: ndarray, nb: int | ndarray, theta: int | ndarray\n) -&gt; tuple[ndarray, ndarray, ndarray, int]\n</code></pre> <p>Check input dimensions and ensure nb/theta are arrays.</p>"},{"location":"tutorials/information-criterion/","title":"Using Information Criterion","text":"<p>By using an Information Criterion (IC), the user does not need to define the exact model orders, but he has to assign a range of orders and let the IC find the best combination of orders.</p> <p>When an input-output model structure of linear or nonlinear type is selected, the information criteria are possible only for SISO systems.</p>"},{"location":"tutorials/input-output_linear_methods/","title":"Input-Output Linear Methods","text":"<p>Every identified linear input-output model is returned according to the following structure:</p> \\[   y_k = G(z)u_k + H(z)e_k \\] <p>where \\(G(z)\\) and \\(H(z)\\) are transfer function matrices of polynomials in \\(z\\), which is the forward shift operator.</p> <p>The underlying generalized model structure is:</p> \\[   A(z)y_k=\\frac{B(z)}{F(z)}u_k+\\frac{C(z)}{D(z)}e_k \\] <p>which can be visualized as block diagram:</p> <p></p> <p>For each structure, the corresponding orders of the various blocks have to be set, since a specific parameter vector (\\(\\Theta\\)) and a corresponding regressor matrix (\\(\\phi\\), in which the various regressor vectors \\(\\varphi_k\\) are stacked) have to be defined Ljung, 1999.`</p> <p>Here's a summary of all the available model structures and polynomials used:</p> Model structure \\(G(z)\\) \\(H(z)\\) FIR (Finite Impulse Response) \\(B(z)\\) 1 ARX (AutoRegressive with eXogenous inputs) \\(A^{-1}(z)B(z)\\) \\(A^{-1}(z)\\) ARMAX (AutoRegressive with Moving Average eXogenous inputs) \\(A^{-1}(z)B(z)\\) \\(A^{-1}(z)C(z)\\) ARMA (AutoRegressive with Moving Average) \\(A^{-1}(z)\\) \\(A^{-1}(z)C(z)\\) ARARX \\(A^{-1}(z)B(z)\\) \\(A^{-1}(z)D^{-1}(z)\\) ARARMAX \\(A^{-1}(z)B(z)\\) \\(A^{-1}(z)D^{-1}(z)C(z)\\) OE (Output Error) \\(F^{-1}(z)B(z)\\) \\(1\\) BJ (Box-Jenkins) \\(F^{-1}(z)B(z)\\) \\(D^{-1}(z)C(z)\\) GEN (Generalized) \\(A^{-1}(z)F^{-1}(z)B(z)\\) \\(A^{-1}(z)D^{-1}(z)C(z)\\) <p>For example, in the case of a SISO (single-input single-output) ARMAX model, we have:</p> \\[   \\Theta=[ a_1 \\: a_2 \\: ... \\: a_{n_a} \\: b_1 \\: ... \\: b_{n_b} \\: c_1 \\: ... \\: c_{n_c}]^T \\\\   \\varphi_k= [    -y_{k-1} \\: \\dots \\: -y_{k-n_a}\\:   u_{k-1-\\theta} \\: \\dots \\: u_{k-n_b-\\theta} \\: \\epsilon_{k-1} \\: \\dots \\:   \\epsilon_{k-n_c} ]^T \\] <p>where \\(\\epsilon_k = y_k - \\hat{y}_k\\) is the prediction error, being \\(\\hat{y}_k\\) the output model, and \\(\\theta\\) is the time-delay.</p> <p>Following naming convention for orders is used throughout SIPPY:</p> <ul> <li>\\(n_a\\) - orders of \\(A(z)\\): the order of \\(n_y\\) outputs.</li> <li>\\(n_b\\) - orders of \\(B(z)\\): the orders of \\(n_y \\times n_u\\) input-output relations.       Note that if an input does not influence an output, set that order equal to \\(0\\);</li> <li>\\(n_c\\) - orders of \\(C(z)\\): the order of \\(n_y\\) error models (numerator in \\(H(z)\\)).</li> <li>\\(n_d\\) - orders of \\(D(z)\\): the order of \\(n_y\\) error models (denominator in \\(H(z)\\)).</li> <li>\\(n_f\\) - orders of \\(F(z)\\): the order of \\(n_y\\) undisturbed output model.</li> <li>\\(\\theta\\): the \\(n_y \\times n_u\\) input-output time-delays.</li> </ul> <p>Here an example for an ARMAX model for a MIMO system (4 inputs \\(\\times\\) 3 outputs) is illustrated. Denoting \\(z^{-1}\\) as the backward shift operator, a MISO approach is employed, that is, for each of the three outputs the identified structure is:</p> \\[   \\begin{split}     (1+a_1 z^{-1}+...+a_{n_a}  z^{-n_a}) y_k &amp; = (b_{1,1} z^{-(1+\\theta_1)}+...+b_{1,n_{b1}} z^{-(n_{b1}+\\theta_1)}) u^{(1)}_k + \\\\                                              &amp; +(b_{2,1} z^{-(1+\\theta_2)}+...+b_{2,n_{b2}} z^{-(n_{b2}+\\theta_2)}) u^{(2)}_k    \\\\                                              &amp; + (b_{3,1} z^{-(1+\\theta_3)}+...+b_{3,n_{b3}} z^{-(n_{b3}+\\theta_3)}) u^{(3)}_k+  \\\\                                              &amp; + (b_{4,1} z^{-(1+\\theta_4)}+...+b_{4,n_{b4}} z^{-(n_{b4}+\\theta_4)}) u^{(4)}_k+  \\\\                                              &amp; + ... + (1+c_{1} z^{-1}+...+c_{n_{c}} z^{-n_{c}}) e_k   \\end{split} \\] Output 1 Output 2 Output 3 Input 1 \\(g_{11}=\\frac{4 z^3 + 3.3 z^2}{z^5 - 0.3 z^4 - 0.25 z^3 - 0.021 z^2}\\) \\(g_{21}=\\frac{-85 z^2 - 57.5 z - 27.7}{z^4 - 0.4 z^3}\\) \\(g_{31}=\\frac{0.2 z^3}{z^4 - 0.1 z^3 - 0.3 z^2}\\) Input 2 \\(g_{12}=\\frac{10 z^2}{z^5 - 0.3 z^4 - 0.25 z^3 - 0.021 z^2}\\) \\(g_{22}=\\frac{71 z + 12.3}{z^4 - 0.4 z^3}\\) \\(g_{32}=\\frac{0.821 z^2 + 0.432 z}{z^4 - 0.1 z^3 - 0.3 z^2}\\) Input 3 \\(g_{13}=\\frac{7 z^2 + 5.5 z + 2.2}{z^5 - 0.3 z^4 - 0.25 z^3 - 0.021 z^2}\\) \\(g_{23}=\\frac{-0.1 z^3}{z^4 - 0.4 z^3}\\) \\(g_{33}=\\frac{0.1 z^3}{z^4 - 0.1 z^3 - 0.3 z^2}\\) Input 4 \\(g_{14}=\\frac{-0.9 z^3 - 0.11 z^2}{z^5 - 0.3 z^4 - 0.25 z^3 - 0.021 z^2}\\) \\(g_{24}=\\frac{0.994 z^3}{z^4 - 0.4 z^3}\\) \\(g_{34}=\\frac{0.891 z + 0.223}{z^4 - 0.1 z^3 - 0.3 z^2}\\) Error model \\(h_{1}=\\frac{z^5 + 0.85 z^4 + 0.32 z^3}{z^5 - 0.3 z^4 - 0.25 z^3 - 0.021 z^2}\\) \\(h_{2}=\\frac{z^4 + 0.4 z^3 + 0.05 z^2}{z^4 - 0.4 z^3}\\) \\(h_{3}=\\frac{z^4 + 0.7 z^3 + 0.485 z^2 + 0.22 z}{z^4 - 0.1 z^3 - 0.3 z^2}\\) <pre><code>n_a = [3, 1, 2]\nn_b = [[2, 1, 3, 2], [3, 2, 1, 1], [1, 2, 1, 2]]\nt_h = [[1, 2, 2, 1], [1, 2, 0, 0], [0, 1, 0, 2]]\n</code></pre>"},{"location":"tutorials/input-output_nonlinear_methods/","title":"Input-Output Nonlinear Methods","text":"<p>Nonlinear dynamic models can be defined in analogy to their linear counterparts.</p> <p>The common notation is adding an \\(N\\) for <code>non-linear</code> in front of the linear model class name.</p> <p>The general form for all nonlinear dynamic input/output models is as follows:</p> \\[   \\hat{y}_k = f(\\varphi_k) \\] <p>where \\(\\varphi_k\\) is the regression vector.</p> <p>A major distinction can be made between models with and without output feedback.</p> <p>In the first case, previous process or model outputs and possibly prediction errors (i.e., \\(\\epsilon_k = y_k - \\hat{y}_k\\)) are included in the regression vector Nelles, 2020.</p> <p>Since for nonlinear problems, the complexity typically increases strongly with the space dimensionality of the input, lower-dimensional NARX and NOE are the most widespread models, so they are the only available structures in SIPPY.</p> <p>One drawback of nonlinear models with output feedback is that the choice of model orders is crucial for the performance.</p> <p>No efficient order determination methods are available in the literature, and the user is often left with a trial-and-error approach.</p> <p>This issue becomes particularly bothersome when different orders (\\(n_a\\), \\(n_b\\)) are considered for the input and output, instead of a common order \\(m\\). Also, a time-delay \\(\\theta\\) is taken into account.</p> <p>Nonlinear input/output models with output feedback are represented in SIPPY by \\emph{Kolmogorov-Gabor} polynomials. % As an example, for a second-order model (\\(m = 2\\)) and a polynomial with degree \\(l = 2\\), the following function results:</p> \\[ \\begin{split}   {y}_k &amp; = p_1 + p_2 u_{k-1} + p_3 u_{k-2} + p_4 y_{k-1} \\\\ &amp; + p_5 y_{k-2}   + p_6 u^2_{k-1} + p_7 u^2_{k-2} + p_8 y^2_{k-1} + p_9 y^2_{k-2} \\\\ &amp; +   p_{10} u_{k-1} u_{k-2} + p_{11} u_{k-1} y_{k-1} + p_{12} u_{k-1} y_{k-2} \\\\ &amp; +   p_{13} u_{k-2} y_{k-1} + p_{14} u_{k-2} y_{k-2} + p_{15} y_{k-1} y_{k-2} \\end{split} \\] <p>which corresponds to a NARX model with \\(n_a = n_b = m = 2\\) and \\(\\theta = 0\\); \\([p_1 \\dots p_{15}]\\) form the parameter vector (\\(\\Theta\\)) to identify.</p>"},{"location":"tutorials/state-space_methods/","title":"State-Space Models and Subspace Identification Method","text":"<p>Process form:</p> \\[   \\begin{cases}     x_{k+1}=Ax_k+Bu_k+w_k \\\\     y_k=Cx_k+Du_k+v_k   \\end{cases} \\] <p>where: \\(y_k \\in \\mathbb{R}^{n_y}\\), \\(x_k \\in \\mathbb{R}^{n}\\), \\(u_k \\in \\mathbb{R}^{n_u}\\), \\(w_k \\in \\mathbb{R}^{n}\\) and \\(v_k \\in \\mathbb{R}^{n_y}\\) are the system output, state, input, state noise and output measurement noise respectively (the subscript \"k\" denotes the \\(k-th\\) sampling time); \\(A \\in \\mathbb{R}^{n\\times n}\\), \\(B \\in \\mathbb{R}^{n\\times n_u}\\),\\(\\: C \\in \\mathbb{R}^{n_y \\times n}\\), \\(D \\in \\mathbb{R}^{n_y \\times n_u}\\) are the system matrices.</p> <p>Innovation form:</p> \\[   \\begin{cases}     x_{k+1}=Ax_k+Bu_k+Ke_k \\\\     y_k=Cx_k+Du_k+e_k   \\end{cases} \\] <p>Predictor form:</p> \\[   \\begin{cases}     x_{k+1}=A_Kx_k+B_Ku_k+Ky_k \\\\     y_k=Cx_k+Du_k+e_k   \\end{cases} \\] <p>where the following relations hold:</p> \\[   A_K=A-KC \\\\   B_K=B-KD \\] <p>where \\(K\\) is the steady-state Kalman filter gain, obtained from Algebraic Riccati Equation.</p> <p>The user has to define the future and past horizons (\\(f\\)  and \\(p\\)  respectively).</p> <p>For traditional methods, that is, <code>N4SID</code>, <code>MOESP</code> and <code>CVA</code> methods, the future and past horizons are equal, set by default \\(f=20\\)  (integer number).</p> <p>For parsimonious methods, that is, <code>PARSIM-P</code>, <code>PARSIM-S</code> and <code>PARSIM-K</code> methods, the future and past horizons can be set, by default: \\(f=20\\) , \\(p=20\\) (integer numbers).</p> <p>After performing the singular value decomposition (SVD) scheduled for the identification, which allows building the suitable subspace from the original data space,</p>"}]}